SUB p3_assist_init {
	/call p3RegisterCommand STOP assistStop 50
	/call p3RegisterCommand FOLLOW assistFollow 50
	/call p3RegisterCommand KILL assistKill 40
	/call p3RegisterCommand KILL assistKillNameCheck 1
	/call p3RegisterCommand KILL assistKillLockCheck 5

	/declare assistSpawnID int outer 0
	/declare assistSpawnIDZone int outer 0
	/declare combatStateCheckTimer timer outer 0
	/declare combatStateTimer timer outer 0
	/declare combatStateTimerMax int outer 50
	/declare combatStateLongTimer timer outer 0
	/declare combatStateLongTimerMax int outer 150
	/declare assistTime timer outer 0
	/declare assistLock bool outer FALSE
	/declare assistMustHaveName string outer -
	/declare assistMustNotHaveName string outer -

	/declare autoAssistHoldTimer timer outer 0
	/declare autoAssistCheckTimer timer outer 0

	/declare autoAssist bool outer 				TRUE
	/declare maxAssistDistance int outer 		500
	/declare useAutoFire bool outer				FALSE
	/declare autoAssistPercent int outer		99
	/declare useEQCombatIndicator bool outer	FALSE

	/varset autoAssist 				${getBotIniOption[Assist.AutoAssist,${autoAssist}]}
	/varset autoAssistPercent		${getBotIniOption[Assist.AutoAssistPercent,${autoAssistPercent}]}
	/varset maxAssistDistance 		${getBotIniOption[Assist.MaxAssistDistance,${maxAssistDistance}]}
	/varset useAutoFire 			${getBotIniOption[Assist.UseAutoFire,${useAutoFire}]}
	/varset assistMustHaveName 		${getBotIniOption[Assist.MustHaveName,${assistMustHaveName}]}
	/varset assistMustNotHaveName 	${getBotIniOption[Assist.MustNotHaveName,${assistMustNotHaveName}]}
	/varset useEQCombatIndicator	${getBotIniOption[Misc.CombatStateUsesGameIndicator,${useEQCombatIndicator}]}

	/RETURN
}

SUB assistKillNameCheck(string cmd, string opts) {
	/declare checkSpawnID int local

	/if (${assistMustHaveName.NotEqual[FALSE]}) {
		/varset checkSpawnID ${getStackCommandOpt[${opts},SPAWNID]}
		/if (${Spawn[id ${checkSpawnID}].CleanName.Upper.Find[${assistMustHaveName.Upper}]}==NULL) /RETURN RESET
	}

	/if (${assistMustNotHaveName.NotEqual[FALSE]}) {
		/varset checkSpawnID ${getStackCommandOpt[${opts},SPAWNID]}
		/if (${Spawn[id ${checkSpawnID}].CleanName.Upper.Find[${assistMustNotHaveName.Upper}]}!=NULL) /RETURN RESET
	}

	/RETURN
}

SUB assistKillLockCheck(string cmd, string opts) {
	|/if (${assistLock}==TRUE) /RETURN RESET
	/RETURN
}

SUB assistKill(string cmd, string opts) {
	/declare checkSpawnID ${getStackCommandOpt[${opts},SPAWNID]}
	/declare sourceName string local ${getStackCommandOpt[${opts},AUTHOR]}

	/if (${Spawn[=${sourceName}].ID}==NULL) /RETURN RESET
	/if (${Spawn[id ${checkSpawnID}].ID}==NULL) /RETURN RESET
	/if (${Spawn[id ${checkSpawnID}].Distance}>${maxAssistDistance}) /RETURN RESET

	/varset assistSpawnID ${checkSpawnID}
	/varset assistSpawnIDZone ${Zone.ID}
	/varset assistTime 1200s

	/declare lock string local
	/varset lock ${getStackCommandOpt[${opts},LOCK]}

	/if (${lock.NotEqual[-]}) {
		/bc locking on ${assistSpawnID}
		/varset assistLock TRUE
	}

	/if (${Me.Pet.ID}) /timed 3 /pet attack

	/RETURN
}

SUB assistStop(string cmd, string opts) {
	/declare holdTimer string local ${getStackCommandOpt[${opts},ASSISTHOLDTIMER]}
	/if (${holdTimer.NotEqual[-]}) {
		/varset autoAssistHoldTimer ${holdTimer}
	}

	| setting this low too fast will trigger buffs in the middle of combat
	|/varset combatStateTimer 5

	/varset assistSpawnID 0
	/varset assistTime 0
	/varset assistLock FALSE

	/RETURN
}

SUB assistFollow(string cmd, string opts) {
	/call assistStop STOP STOP;ASSISTHOLDTIMER=20
	/RETURN
}


SUB assistMaintenance() {
	/call updateCombatStateTimer

	/if (${assistSpawnID}!=0) {
		/if (${assistSpawnIDZone}!=${Zone.ID}) {
			/call assistStop
			/RETURN
		}

		/if (${Spawn[id ${assistSpawnID}].ID}==NULL || ${Spawn[id ${assistSpawnID}].Dead}==TRUE) {
			/call assistStop
			/RETURN
		}
		
		/if (${assistMustHaveName.NotEqual[FALSE]}) {
			/if (${Spawn[id ${assistSpawnID}].CleanName.Upper.Find[${assistMustHaveName.Upper}]}==NULL) {
				/call assistStop
				/RETURN
			}
		}
		/if (${assistMustNotHaveName.NotEqual[FALSE]}) {
			/if (${Spawn[id ${assistSpawnID}].CleanName.Upper.Find[${assistMustNotHaveName.Upper}]}!=NULL) {
				/call assistStop
				/RETURN
			}
		}
	}

	/call checkAutoAssist

	/RETURN
}

SUB checkAutoAssist() {
	/if (${autoAssistHoldTimer}>0) /return
	/if (${autoAssistCheckTimer}>0) /return
	/if (${autoAssist}==FALSE) /return
	/if (${assistSpawnID}!=0) /return

	/varset autoAssistCheckTimer 5

	/declare i int local
	/declare netbotName string local
	/declare targetID int local 0

	/for i 1 to ${NetBots.Counts}
		/varset netbotName ${NetBots.Client[${i}]}

		/if (${NetBots[${netbotName}].InZone}==FALSE) /continue
		/if (${NetBots[${netbotName}].Attacking}==FALSE) /continue
		/if (${NetBots[${netbotName}].TargetID}==0) /continue
		/if (${Spawn[id ${NetBots[${netbotName}].TargetID}].Dead}==TRUE) /continue
		/if (${Spawn[pc ${netbotName}].Distance} > ${maxAssistDistance}) /continue

		/if (${Spawn[id ${NetBots[${netbotName}].TargetID}].Type.NotEqual[PC]} && ${NetBots[${netbotName}].TargetHP}<=${autoAssistPercent}) {
			/varset targetID ${NetBots[${netbotName}].TargetID}
		}

	/next i

	/if (${targetID}!=0) {
   		/invoke ${cq.Append[KILL;AUTHOR=${Me.CleanName};SPAWNID=${targetID}]}
	}

	/RETURN
}

SUB updateCombatStateTimer() {
	/declare i int local
	/declare botName string local

	/if (${combatStateCheckTimer}>0) /return
	/varset combatStateCheckTimer 5

	/if (${Me.CombatState.Equal[COMBAT]}) {
		/varset combatStateTimer ${combatStateTimerMax}
		/varset combatStateLongTimer ${combatStateLongTimerMax}		
		/return
	}

	/for i 1 to ${NetBots.Counts}
		/varset botName ${NetBots.Client[${i}]}

		/if (${useEQCombatIndicator}==TRUE) {
			/if (${NetBots[${botName}].CombatState}==0) {
				/varset combatStateTimer ${combatStateTimerMax}
				/varset combatStateLongTimer ${combatStateLongTimerMax}
				/RETURN
			}
		} else {
			/if (${NetBots[${botName}].Attacking} == TRUE) {
				/if (${NetBots[${botName}].Zone} != ${Zone.ID}) /continue
				/if (${Spawn[pc ${botName}].Distance} > ${maxAssistDistance}) /continue

				/varset combatStateTimer ${combatStateTimerMax}
				/varset combatStateLongTimer ${combatStateLongTimerMax}
				/return
			}
		}

	/next i
	/RETURN
}

SUB p3_assist_tags_init {
	/declare assistTags list outer
	/declare tempCombatTags list outer

	/declare iniPastTags string outer -

	/varset iniPastTags ${getBotIniOption[Misc.StartupAssistTags,${iniPastTags}]}

	/if (${commandLine[${cmdPAST}].Length}>0) {
		/bc Adding PAST tags from startup: ${commandLine[${cmdPAST}].Replace[ ,]}
		/invoke ${assistTags.Append[${commandLine[${cmdPAST}].Replace[ ,]}]}
	}

	/call processIniPastTags

	/RETURN
}



SUB assist_tagsMaintenance() {
	/call checkExpiringTags

	/RETURN
}


SUB checkExpiringTags() {

	/declare i int local
	/declare tName string local

	/if (${assistTags.Count}==0) /RETURN
	|/echo count: ${assistTags.Count}

	/for i 0 to ${Math.Calc[${assistTags.Count}-1]}
		/varset tName ${assistTags.Item[${i}]}
		|/echo checking: ${tName}...

		/if (${Defined[past_${tName}]}==TRUE) {
			/if (${past_${tName}}==0) {
				/bc detected expired tag: ${tName} -- should remove
				/call wipeLockout past_${tName}
				/call removePastTags ${tName}
				/return
			}
		}
	/next i

	/RETURN
}

SUB validateAssistTags(string tagsToCheck, bool asOrOperator) {
	/declare i int local
	/declare t string local 
	/declare matches int local 0
	/declare res bool local TRUE
	/declare checkTags list local
	/declare fullTags list local

	/if (${assistTags.Count}>0) {
		/vardata fullTags assistTags.Splice
	}

   /if (${tempCombatTags.Count}>0) {
      /for i 0 to ${Math.Calc[ ${tempCombatTags.Count}-1 ]}
         /invoke ${fullTags.Append[${tempCombatTags.Item[${i}]}]}
      /next i
   }

	/invoke ${checkTags.Append[${tagsToCheck}]}

	/for i 0 to ${Math.Calc[${checkTags.Count}-1]}
		/if (${fullTags.Contains[${checkTags.Item[${i}]}]}) {
			/varset matches ${Math.Calc[${matches}+1]}
		}
	/next i

	/if (${asOrOperator}==TRUE && ${matches}>0) {
		/varset res TRUE
	} else /if (${matches}>0 && ${matches} >= ${checkTags.Count}) {
		/varset res TRUE
	} else {
		/varset res FALSE
	}

	/return ${res}

	/RETURN
}

SUB removePastTags(string remTags) {
	/declare i int local 
	/declare tok string local

	/for i 1 to ${Math.Calc[${remTags.Count[,]}+1]}
		/varset tok ${remTags.Token[${i},,]}
		/if (${assistTags.Contains[${tok.Lower}]}==TRUE) {
			/invoke ${assistTags.Remove[${tok}]}
			/bc Removed ${tok} from assist tags.
		}
	/next i

	/invoke ${cq.Append[TAGSCHANGED;]}

	/RETURN
}

SUB processIniPastTags() {
	/declare i int local
	/declare tok string local

	|/declare importTags list local
	|/invoke ${importTags.Append[${iniPastTags}]}

	/for i 1 to ${Math.Calc[${iniPastTags.Count[,]}+1]}
		/varset tok ${iniPastTags.Token[${i},,]}
		/if (${assistTags.Contains[${tok.Lower}]}==FALSE) {
			/invoke ${assistTags.Append[${tok}]}
			/bc Adding ${tok} to assist tags from INI setting.
		}
	/next i

	/invoke ${cq.Append[TAGSCHANGED;]}
	/RETURN
}

SUB p3_autoabilities_init {
	/declare autoAbilitiesCheckTimer timer outer 0

	/if (${iniSectionExists[AutoAbilities]}==FALSE) /call autoabilitiesSetupINI

	/RETURN
}

SUB autoabilitiesSetupINI() {
	/invoke ${getBotIniOption[AutoAbilities.Sense Heading,CastableOnlyResting]}
	/RETURN
}

SUB autoabilitiesMaintenance() {
	/if (${autoAbilitiesCheckTimer}>0) /return

	/varset autoAbilitiesCheckTimer 2
	/call checkAutoAbilities

	/RETURN
}

SUB checkAutoAbilities() {
	/declare i int local
	/declare abilityName string local

	/for i 1 to ${iniAutoAbilities.Size}
		/varset abilityName ${iniAutoAbilities[${i},1]}

		/if (${abilityName.Equal[-]}) /break

		/if (${Me.AbilityReady[${abilityName}]}==FALSE) {
			/continue
		}

		/if (${iniAutoAbilities[${i},${bRequireBehindAssistTarget}].NotEqual[-]}) {
			/if (${assistSpawnID}==0) /continue
			/if (${Stick.Active}==FALSE) /continue
			/echo distcheck: ${Spawn[id ${assistSpawnID}].MaxRangeTo} ${Spawn[id ${assistSpawnID}].Distance} ${Stick.Behind}
			/if (${Spawn[id ${assistSpawnID}].Distance} > ${Spawn[id ${assistSpawnID}].MaxRangeTo}) /continue
			/if (${Stick.Behind}==FALSE) /continue
		}

		/if (${iniAutoAbilities[${i},${bCastableOnlyResting}].NotEqual[-]}) {
			/if (${assistSpawnID}!=0) /continue
		}

		/if (${iniAutoAbilities[${i},${bSelfUnderHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} >= ${iniAutoAbilities[${i},${bSelfUnderHP}]}) /continue
		}

		/if (${iniAutoAbilities[${i},${bSelfOverHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} < ${iniAutoAbilities[${i},${bSelfUnderHP}]}) /continue
		}

		/if (${iniAutoAbilities[${i},${bRequireAssistTarget}].NotEqual[-]}) {
			/if (${assistSpawnID}==0) /continue
		}

		/if (${iniAutoAbilities[${i},${bFreeze}].NotEqual[-]}) {
			/delay ${iniAutoAbilities[${i},${bFreeze}].NotEqual[-]}
		}

		/if (${iniAutoAbilities[${i},${bDoCommand}].NotEqual[-]}) {
			/call p3command "${iniAutoAbilities[${i},${bDoCommand}]}"
		}

		/doability "${abilityName}"
	/next i
	

	/RETURN
}

SUB p3_autodebuff_init() {

	|/call p3RegisterCommand KILL autoMezKillCheck 5

	/declare autoDebuffIDsList list outer
	/declare autoDebuffCheckTimer timer outer 0
	/declare autoDebuffCheckTimerDelay int outer 10
	/declare autoDebuffMobRadius int outer 50
	/declare autoDebuffSpawnSearch string outer NPC LOS TARGETABLE

	/declare workingOnADebuff bool outer FALSE

	/declare autoDebuffEnabled bool outer TRUE

	/varset autoDebuffEnabled 				${getBotIniOption[AutoDebuff.AutoDebuffEnabled,${autoDebuffEnabled}]}
	/varset autoDebuffMobRadius 			${getBotIniOption[AutoDebuff.AutoDebuffRadius,${autoDebuffMobRadius}]}
	/varset autoDebuffSpawnSearch 			${getBotIniOption[AutoDebuff.AutoDebuffSpawnSearch,${autoDebuffSpawnSearch}]}

	/varset autoDebuffSpawnSearch ${autoDebuffSpawnSearch} RADIUS ${autoDebuffMobRadius} RANGE ${autoDebuffSpawnSearch}
	

	/declare autoDebuffSpellIDsList list outer
	/call populateAutoDebuffSpellIDs

	/if (${autoDebuffSpellIDsList.Count}==0) {
		/echo There are no AutoDebuff-flagged entries in [CombatSpells].  Disabling auto-debuff routines.
		/varset autoDebuffEnabled FALSE
	}

	/RETURN
}


SUB autodebuffMaintenance() {
	/if (${autoDebuffCheckTimer}>0) /return
	/varset autoDebuffCheckTimer ${autoDebuffCheckTimerDelay}

	/if (${workingOnADebuff}==TRUE) /RETURN RESET

	/if (${autoDebuffEnabled}==FALSE) /RETURN
	/if (${Me.Casting.ID}!=NULL) /return

	/if (${Stick.Active}==TRUE || ${Nav.Active}==TRUE) /return

	/if (${workingOnADebuff}==FALSE) /call checkAutoDebuffs


	/RETURN
}

SUB checkAutoDebuffs() {
	/declare xspawn spawn local
	/declare i int local

	/declare targetEntry string local 
	/declare targetID string local 
	/declare targetZone string local 

	| SCAN AREA FOR NEW MOBS TO DEBUFF
	/declare mobCountInArea int local ${SpawnCount[${autoDebuffSpawnSearch}]}
	/if (${mobCountInArea}>0) {
		/for i 1 to ${mobCountInArea}
			/vardata xspawn NearestSpawn[${i},${autoDebuffSpawnSearch}]
			/if (${xspawn.Aggressive}==FALSE) /continue
			/call addTargetForDebuffs ${xspawn.ID}
		/next i
	}

	| CLEAN UP THE LIST OF ANYTHING DEAD/GONE, ETC
	/for i ${Math.Calc[${autoDebuffIDsList.Count}-1]} downto 0
		/varset targetEntry ${autoDebuffIDsList.Item[${i}]}
		/varset targetID ${targetEntry.Arg[1,_]}
		/varset targetZone ${targetEntry.Arg[2,_]}

		/if (${Zone.ID} != ${targetZone} || ${Spawn[id ${targetID}].Dead}==TRUE || ${SpawnCount[id ${targetID}]}==0) {
			/invoke ${autoDebuffIDsList.Erase[${i}]}
		}

		/if (${Spawn[id ${targetID}].Distance}>150 || ${Spawn[id ${targetID}].LineOfSight}==FALSE) {
			/invoke ${autoDebuffIDsList.Erase[${i}]}
		}

	/next i

	/if (${autoDebuffIDsList.Count}==0) /RETURN

	/for i 0 to ${Math.Calc[${autoDebuffIDsList.Count}-1]}
		|/echo ${autoDebuffIDsList.Item[${i}]}
	/next i

	| PERFORM DEBUFFS
	/for i 0 to ${Math.Calc[${autoDebuffIDsList.Count}-1]}
		/if (${autoDebuffIDsList.Item[${i}].Arg[3,_].Equal[1]}) /continue
		/call processDebuffsForTargetID ${autoDebuffIDsList.Item[${i}].Arg[1,_]} TRUE
		/if (${Macro.Return}==TRUE) {
			/varset workingOnADebuff TRUE
			/varset buffCheckTimer 60
			/break
		}
	/next i

	/varset workingOnADebuff FALSE

	/RETURN
}

SUB processDebuffsForTargetID(int targetID, bool requireAutoDebuffFlag) {
	/declare i int local
	/declare castName string local
	/declare spellTime int local
	/declare debuffResult string local
	/declare castSpell spell local
	/declare timerName string local
	/declare minDuration int local 30
	/declare requireMana int local 0
	/declare entry string local
	/declare maxResists int local 5
	/declare currentResistCount int local 0
	/declare cancelConditions string local
	/declare lifeDeficit int local
	/declare lifeRatio int local

	/for i 1 to ${iniCombatSpells.Size}
		/varset currentResistCount 0
		/varset cancelConditions TARGETDEAD|

		/if (${iniCombatSpells[${i},1].Equal[-]}) /break

		/if (${requireAutoDebuffFlag}==TRUE) {
			/if (${iniCombatSpells[${i},${bAutoDebuff}].Equal[-]} && ${iniCombatSpells[${i},${bAutoDebuffOnly}].Equal[-]}) /continue
		}

		/if (${iniCombatSpells[${i},${bEnabled}].Equal[NO]}) /continue

		/if (${iniCombatSpells[${i},${bNotIfAssistTag}].NotEqual[-]}) {
			/if (${assistTags.Count}>0 || ${persistentAssistTags.Count}>0) {
				/call validateAssistTags ${iniCombatSpells[${i},${bNotIfAssistTag}]} TRUE
				/if (${Macro.Return}==TRUE) /continue
			}
		}

		/if (${iniCombatSpells[${i},${bRequireAssistTag}].NotEqual[-]}) {
			/if (${assistTags.Count}==0 && ${persistentAssistTags.Count}==0) /continue
			/call validateAssistTags ${iniCombatSpells[${i},${bRequireAssistTag}]}
			/if (${Macro.Return}==FALSE) /continue
		}

		/if (${iniCombatSpells[${i},${bTargetOverLevel}].NotEqual[-]}) {
			/if (${Spawn[id ${targetID}].Level} < ${iniCombatSpells[${i},${bTargetOverLevel}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bTargetUnderLevel}].NotEqual[-]}) {
			/if (${Spawn[id ${targetID}].Level} >= ${iniCombatSpells[${i},${bTargetUnderLevel}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} < ${iniCombatSpells[${i},${bSelfOverMana}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bRequireMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 45]} < ${iniCombatSpells[${i},${bRequireMobsInProximity}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bRequireMaxMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 45]} > ${iniCombatSpells[${i},${bRequireMaxMobsInProximity}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bRequireTargetClass}].NotEqual[-]}) {
			|/echo ${Spawn[id ${targetID}].Class.ShortName} === ${iniCombatSpells[${i},${bRequireTargetClass}]}
			|/echo ${Select[${Spawn[id ${targetID}].Class.ShortName},${iniCombatSpells[${i},${bRequireTargetClass}]}]}
			/if (${Select[${Spawn[id ${targetID}].Class.ShortName},${iniCombatSpells[${i},${bRequireTargetClass}]}]}==0) /continue
		}

		/if (${iniCombatSpells[${i},${bTargetUnderHP}].NotEqual[-]}) {
			/call fullTarget ${targetID}
			/if (${Target.PctHPs} > ${iniCombatSpells[${i},${bTargetUnderHP}]}) /continue
		}

		/if (${iniCombatSpells[${i},${bTargetOverHP}].NotEqual[-]}) {
			/call fullTarget ${targetID}
			/if (${Target.PctHPs} <= ${iniCombatSpells[${i},${bTargetOverHP}]}) /continue
			/varset cancelConditions ${cancelConditions}|TARGETUNDERHP:${iniCombatSpells[${i},${bTargetOverHP}]}
		}

		/if (${iniCombatSpells[${i},${bTargetLifeManaRatio}].NotEqual[-]}) {
			/call fullTarget ${targetID}
			/varset lifeDeficit ${Math.Calc[100-${Target.PctHPs}]}
			/varset lifeRatio ${iniCombatSpells[${i},${bTargetLifeManaRatio}]}
			/if (${Me.PctMana} < ${Math.Calc[100-(${lifeDeficit}/${lifeRatio})]}) {
				/continue
			}
		}

		/if (${iniCombatSpells[${i},${bMaxResists}].NotEqual[-]}) {
			/varset maxResists ${iniCombatSpells[${i},${bMaxResists}]}
		}

		/varset castName ${iniCombatSpells[${i},1]}

		/call getSpellFromCastRequest "${castName}"
		/vardata castSpell ${Macro.Return}

		/varset spellTime ${castSpell.Duration.TotalSeconds}

		/if (${iniCombatSpells[${i},${bRecastDelay}].NotEqual[-]}) {
			/varset spellTime ${Math.Calc[${spellTime} + ${iniCombatSpells[${i},${bRecastDelay}]}]}
		}

		/varset timerName detriTimer_${targetID}_${castSpell.ID}

		| ALREADY TIMER FOR IT? ITS LOCKED OUT...
		/if (${Defined[${timerName}]}==TRUE) {
			/if (${${timerName}}>0) /continue
			/deletevar ${timerName}
		}

		|/if (${FindItemCount[=${castName}]}>0) {
		|	/call waitForInt "FindItem[=${castName}].TimerReady" 0
		|}

		| LAST CHANCE DEAD/GONE CHECK
		/if (${Spawn[id ${targetID}].Dead}==TRUE || ${SpawnCount[id ${targetID}]}==0) /break

		/if (${iniCombatSpells[${i},${bMemInGem}].NotEqual[-]}) {
			/if (${Me.Gem[${castName}]}==NULL) {
				/call memorizeSpellInGem "${castName}" ${iniCombatSpells[${i},${bMemInGem}]}
			}
		}

		| A CAST WILL HAPPEN -- PRE-TARGET AND CHECK FOR BUFF
		/call fullTarget ${targetID}
		/if (${Target.Buff[${castSpell.Name}].ID}!=NULL) {
			/if (${Math.Calc[${Target.BuffDuration[${castSpell.Name}].TotalSeconds} * ${castSpell.MyDuration.TotalSeconds} > 0.3]}) {
				/varset spellTime ${Target.BuffDuration[${castSpell.Name}].TotalSeconds}
				/echo Detected debuff already on target. Locking out for duration: ${spellTime}
				/call lockout ${timerName} ${spellTime}
				/continue
			}
		}

		/if (${isCastReady[${castName}]}==FALSE) {
			/echo spell was not ready:  ${castName}
			/RETURN FALSE
		}
		
		/if (${iniCombatSpells[${i},${bDoCommand}].NotEqual[-]}) {
			/docommand ${iniCombatSpells[${i},${bDoCommand}]}
			/delay 3
		}

		/invoke (${cq.Append[CAST;SPELL=${castName};TARGETID=${targetID};SRC=iniCombatSpells;SRCIDX=${i};ONRESULT=onDebuffCastResult;cancelConditions=${cancelConditions}]})
		/RETURN TRUE
	/next i

	/RETURN FALSE
}

SUB populateAutoDebuffSpellIDs() {
	/declare i int local
	/declare cSpell spell local

	/for i 1 to ${iniCombatSpells.Size}
		/if (${iniCombatSpells[${i},1].Equal[-]}) /break
		/if (${iniCombatSpells[${i},${bEnabled}].Equal[NO]}) /continue
		/if (${iniCombatSpells[${i},${bAutoDebuff}].Equal[-]} && ${iniCombatSpells[${i},${bAutoDebuffOnly}].Equal[-]}) /continue

		/call getSpellFromCastRequest "${iniCombatSpells[${i},1]}"
		/vardata cSpell ${Macro.Return}

		/invoke ${autoDebuffSpellIDsList.Append[${cSpell.ID}]}
	/next i

	/return

}

SUB queueContainsCast(string castName, string targetID) {
	/declare i int local 

	/for i 0 to ${Math.Calc[${cq.Count}-1]}
		/if (${cq.Item[${i}].Find[SPELL=${castName}]}!=NULL && ${cq.Item[${i}].Find[TARGETID=${targetID}]}) /RETURN TRUE
	/next i
	
	/RETURN FALSE
}

SUB onDebuffCastResult(string result, string opts) {
	/varset workingOnADebuff FALSE

	/declare targetID string local ${getStackCommandOpt[${castingOpts},TARGETID]}
	/declare cSpellName string local ${getStackCommandOpt[${castingOpts},SPELL]}
	/declare cSpell spell local

	/call getSpellFromCastRequest "${cSpellName}"
	/vardata cSpell ${Macro.Return}

	/declare before string local ${targetID}_${Zone.ID}_${cSpell.ID}_0
	/declare after string local ${targetID}_${Zone.ID}_${cSpell.ID}_1

	/invoke ${autoDebuffIDsList.Replace[${before},${after}]}

	/RETURN
}


SUB addTargetForDebuffs(int targetID) {
	/declare i int local
	/declare spellID string local

	/for i 0 to ${Math.Calc[${autoDebuffSpellIDsList.Count}-1]}

		/varset spellID ${autoDebuffSpellIDsList.Item[${i}]}

		/if (${autoDebuffIDsList.Contains[${targetID}_${Zone.ID}_${spellID}_0]}) /continue
		/if (${autoDebuffIDsList.Contains[${targetID}_${Zone.ID}_${spellID}_1]}) /continue

		|/echo add: ${targetID}_${Zone.ID}_${autoDebuffSpellIDsList.Item[${i}]}_0
		/invoke ${autoDebuffIDsList.Append[${targetID}_${Zone.ID}_${autoDebuffSpellIDsList.Item[${i}]}_0]}
	/next i

	/RETURN
}


SUB xcheckAutoMez() {
	/if (${autoMezCheckTimer}>0) /RETURN FALSE
	/if (${Stick.Active}==TRUE) /RETURN FALSE
	/if (${Me.Moving}==TRUE) /RETURN FALSE
	/if (${Me.Invis}==TRUE) /RETURN FALSE

	/varset autoMezCheckTimer 5

}

SUB xmezCastRequestResult(string result, string opts) {
	/declare targetID int local ${getStackCommandOpt[${opts},TARGETID]}
	/declare cSpellName string local ${getStackCommandOpt[${opts},SPELL]}
	/declare cSpell spell local

	/call getSpellFromCastRequest "${cSpellName}"
	/vardata cSpell ${Macro.Return}

	/if (${result.Find[PASS_]}!=NULL) {
		/call lockout mez_${targetID} ${Math.Calc[${cSpell.Duration.TotalSeconds}-${autoMezTimerMarginSeconds}]}s
	}

	/RETURN
}
SUB p3_autodispell_init() {
	/declare autoDispellEnabled bool outer FALSE
	/declare autoDispellCheckDelay int outer 10
	/declare autoDispellSpell string outer -

	/varset autoDispellEnabled 				${getBotIniOption[Misc.AutoDispellEnabled,${autoDispellEnabled}]}
	/varset autoDispellCheckDelay 			${getBotIniOption[Misc.AutoDispellCheckDelay,${autoDispellCheckDelay}]}
	/varset autoDispellSpell 				${getBotIniOption[Misc.AutoDispellSpell,${autoDispellSpell}]}

	/declare autoDispellCheckTimer timer outer 0

	/RETURN
}


SUB autodispellMaintenance() {
	/if (${autoDispellEnabled}==TRUE && ${autoDispellCheckTimer}==0) {
		/call checkAutoDispell
		/varset autoDispellCheckTimer ${autoDispellCheckDelay}
	}

	/RETURN
}


SUB checkAutoDispell() {
	/if (${assistSpawnID}==0) /return

	/if (${targetHasBeneficial[]}==TRUE) {
		/if (${isCastReady[${autoDispellSpell}]}==FALSE) /RETURN
		|/if (${Cast.Ready[${autoDispellSpell}]}==FALSE) /RETURN
		/invoke (${cq.Append[CAST;SPELL=${autoDispellSpell};TARGETID=${assistSpawnID};]})
	}

	/RETURN
}




SUB targetHasBeneficial() {
	| FOR SOME REASON NOT TARGETTING ANYTHING?
	/if (${Target.ID}==NULL) /return
	/if (${assistSpawnID}==0) /return
	/if (${Target.BuffsPopulated}==FALSE) /return

	/declare i int local
	/declare hasDispellable bool local FALSE

	/for i 1 to ${Target.BuffCount}
		/if (${Target.Buff[${i}].Beneficial}==TRUE && ${Target.Buff[${i}].Name.Upper.Find[MITIGATION OF THE MIGHTY]}==NULL) {
			/return TRUE
			|/varset hasDispellable TRUE
		}
	/next i

	/return FALSE

}

SUB p3_automed_init() {
	/call p3RegisterCommand CAST autoMedCast 10


	/declare doAutoMed bool outer FALSE
	/declare checkAutoMedTimer timer outer 0
	/declare medLockoutTimer timer outer 0


	/call pauseAutoMed 2s

	/declare ignoreAutoMed bool outer TRUE
	/if (${Select[${Me.Class.ShortName},${manaRegenClasses}]}>0) /varset ignoreAutoMed FALSE
	/varset ignoreAutoMed ${getBotIniOption[Misc.IgnoreAutoMed,${ignoreAutoMed}]}


	/RETURN
}


SUB automedMaintenance() {
	/if (${doAutoMed}==TRUE && ${ignoreAutoMed}==FALSE) /call checkAutoMed
	/RETURN
}

SUB autoMedCast(string cmd, string opts) {
	/call pauseAutoMed 2s
	/RETURN
}

SUB setAutoMed(bool mode) {
	/varset doAutoMed ${mode}

	/if (${mode}==TRUE) /bc Auto-Med is now on.
	/if (${mode}==FALSE) /bc Auto-Med is now off.
	/RETURN
}

SUB checkAutoMed() {
	/if (${checkAutoMedTimer}>0) /return
	/varset checkAutoMedTimer 3s

	/if (${medLockoutTimer}>0) {
		|/bc Meditate locked out. Time remaining: ${medLockoutTimer}
		/return
	}

	/if (${movingTimer}>0) /return
	/if (${Me.State.Equal[MOUNT]}==TRUE) /return
	/if (${Me.Casting.ID}!=NULL) /return
	/if (${Me.PctMana} >= 99) /return
	/if (${checkOpenWindows[]}==TRUE) /return
	
	/if (${assistSpawnID}!=0 && (${useMeleeCombat}==TRUE || ${autoFireAssist}==TRUE)) /return

	| PREVENT MEDDING AND STAND, IF THERES A TIMER ACTIVE FROM BEING HIT
	/echo medlockouttime: ${medLockoutTimer}

	/if (${medLockoutTimer}>0) {
		/if (${Me.Sitting}==TRUE) /stand
		/return
	}

	/if (${Me.State.Equal[STAND]}==TRUE) {
		/if (${Me.Sitting}==FALSE) /sit
	}

	/RETURN
}


SUB pauseAutoMed(string waitTime) {
	/if (${Defined[waitTime]}==FALSE) {
		/declare waitTime string local 10s
	}

	/varset medLockoutTimer ${waitTime}
	|/echo Stopping automed for ${waitTime}
	/if (${Me.Sitting}==TRUE) /stand
	/RETURN
}

SUB p3_automez_init() {

	/call p3RegisterCommand KILL autoMezKillCheck 5

	/declare autoMezList list outer
	/declare autoMezCheckTimer timer outer 0
	/declare autoMezLastCastIndex int outer 0

	/declare autoMezActionTakenTimer timer outer 0
	/declare autoMezEnabled bool outer FALSE
	/declare autoMezSpell string outer NONE
	/declare autoMezTimerMarginSeconds string outer 10
	/declare autoMezMustHaveName string outer -
	/declare autoMezMobLevels string outer 10 65
	/declare autoMezMobRadius string outer 100
	/declare autoMezSpawnSearch string outer NPC LOS TARGETABLE

	/varset autoMezEnabled 				${getBotIniOption[AutoMez.AutoMezEnabled,${autoMezEnabled}]}
	/varset autoMezSpell 				${getBotIniOption[AutoMez.AutoMezSpell,${autoMezSpell}]}
	/varset autoMezMobLevels 			${getBotIniOption[AutoMez.AutoMezMobLevelRange,${autoMezMobLevels}]}
	/varset autoMezMobRadius 			${getBotIniOption[AutoMez.AutoMezMobRadius,${autoMezMobRadius}]}
	/varset autoMezTimerMarginSeconds 	${getBotIniOption[AutoMez.AutoMezTimerMarginSeconds,${autoMezTimerMarginSeconds}]}
	/varset autoMezMustHaveName 		${getBotIniOption[AutoMez.AutoMezMustHaveName,${autoMezMustHaveName}]}

	/varset autoMezSpawnSearch ${autoMezSpawnSearch} RADIUS ${autoMezMobRadius} RANGE ${autoMezMobLevels}
	
	/RETURN
}


SUB automezMaintenance() {

	/if (${autoMezEnabled}==TRUE) {

		/call checkAutoMez
		/if (${Macro.Return}==TRUE) /varset autoMezActionTakenTimer 100

		/if (${Macro.Return}==FALSE && ${autoMezActionTakenTimer}>0) {
			/call clearStackActions CAST
		}

		/if (${autoMezActionTakenTimer}>0) /RETURN RESET
	}

	/RETURN
}


SUB autoMezKillCheck() {
	/if (${autoMezActionTakenTimer}>0) {
		/RETURN RESET
	}

	/RETURN
}

SUB checkAutoMez() {
	/if (${autoMezCheckTimer}>0) /RETURN FALSE
	/if (${Stick.Active}==TRUE) /RETURN FALSE
	/if (${Me.Moving}==TRUE) /RETURN FALSE
	/if (${Me.Invis}==TRUE) /RETURN FALSE

	/varset autoMezCheckTimer 5

	/declare spawnsInRangeCount int local ${SpawnCount[${autoMezSpawnSearch}]}
	/declare i int local
	/declare j int local
	/declare xSpawn spawn local
	/declare targetID int local
	/declare xSpell spell local
	/declare useMezSpell string local
	/declare startIndex int local 0

	/call getReadyMezSpell

	/if (${Macro.Return.Equal[-]}) /RETURN
	/varset useMezSpell ${Macro.Return}

	/if (${isCastReady[${useMezSpell}]}==FALSE) /RETURN


	| SCAN AND ADD CANDIDATES
	/if (${spawnsInRangeCount}>0) {

		/for i 1 to ${spawnsInRangeCount}
			/vardata xSpawn NearestSpawn[${i},${autoMezSpawnSearch}]
			/if (${Spawn[id ${xSpawn.ID}].ID}==${assistSpawnID}) /continue
			/if (${Spawn[id ${xSpawn.ID}].Dead}==TRUE) /continue
			/if (${Spawn[id ${xSpawn.ID}].ID}==NULL) /continue
			/if (${Spawn[id ${xSpawn.ID}].Type.Equal[Pet]}) /continue
			/if (${isNetBotAttackingID[${xSpawn.ID}]}==TRUE) /continue
			/if (${assistSpawnID}==${xSpawn.ID}) /continue

			/if (${autoMezMustHaveName.NotEqual[FALSE]}) {
				/if (${checkAutoMezNameMatch[${xSpawn.CleanName}]}==FALSE) /continue
			}


			/if (${autoMezList.Index[${xSpawn.ID}]}==-1) {
				|/echo add to maint list: ${xSpawn.ID} ${xSpawn}
				/invoke ${autoMezList.Append[${xSpawn.ID}]}
			}

		/next i
	}


	| MAINTENANCE: CLEANUP ANYTHING THAT MIGHT BE DEAD OR GONE OR IS BEING ATTACKED BY A NETBOT
	/if (${autoMezList.Count}>0) {
		/for i ${Math.Calc[${autoMezList.Count}-1]} downto 0
			/if (${Spawn[id ${autoMezList.Item[${i}]}].Aggressive}==FALSE || ${autoMezList.Item[${i}]}==${assistSpawnID} || ${Spawn[id ${autoMezList.Item[${i}]}].Dead}==TRUE || ${Spawn[id ${autoMezList.Item[${i}]}].ID}==NULL || ${isNetBotAttackingID[${autoMezList.Item[${i}]}]}==TRUE) {
				/call wipeLockout mez_${autoMezList.Item[${i}]}
				/invoke ${autoMezList.Erase[${i}]}
				/continue
			}
		/next i
	}

	/if (${autoMezList.Count}==0) {
		/varset autoMezActionTakenTimer 0
		/RETURN FALSE
	}


	/if (${autoMezLastCastIndex} <= ${Math.Calc[${autoMezList.Count}-1]}) /varset startIndex ${autoMezLastCastIndex}

	| PROCESS LIST AND MEZ
	/for i ${startIndex} to ${Math.Calc[${autoMezList.Count}-1]}
		/varset targetID ${autoMezList.Item[${i}]}

		/if (${Spawn[id ${targetID}].Dead}) /continue

		/call fullTarget ${targetID}

		/if (${Target.Mezzed.ID}!=NULL) {
			/if (${Target.Mezzed.Duration.TotalSeconds} > ${autoMezTimerMarginSeconds}) {
				/echo detected already-mezzed. locking out for ${Math.Calc[${Target.Mezzed.Duration.TotalSeconds}-${autoMezTimerMarginSeconds}]}s
				/call lockout mez_${targetID} ${Math.Calc[${Target.Mezzed.Duration.TotalSeconds}-${autoMezTimerMarginSeconds}]}s
				/continue
			}
		}

		/if (${Target.Mezzed.ID}==NULL || ${isLockoutExpired[mez_${targetID}]}==TRUE) {
			/call clearStackActions CAST
			/invoke (${cq.Append[CAST;SPELL=${useMezSpell};TARGETID=${targetID};CANCELCONDITIONS=NETBOTATTACKING:${targetID}|TARGETISASSITTARGET;ONRESULT=mezCastRequestResult;]})
			/varset autoMezLastCastIndex ${i}
			/RETURN TRUE
		}
	/next i

	/varset autoMezLastCastIndex 0
	/RETURN FALSE
}

SUB mezCastRequestResult(string result, string opts) {
	/declare targetID int local ${getStackCommandOpt[${opts},TARGETID]}
	/declare cSpellName string local ${getStackCommandOpt[${opts},SPELL]}
	/declare cSpell spell local

	/call getSpellFromCastRequest "${cSpellName}"
	/vardata cSpell ${Macro.Return}

	/if (${result.Find[PASS_]}!=NULL) {
		/call lockout mez_${targetID} ${Math.Calc[${cSpell.Duration.TotalSeconds}-${autoMezTimerMarginSeconds}]}s
	}

	/RETURN
}

SUB checkAutoMezNameMatch(string n) {
	/declare i int local

	/for i 1 to ${Math.Calc[${autoMezMustHaveName.Count[,]}+1]}
		/if (${n.Find[${autoMezMustHaveName.Token[${i},,]]}]}!=NULL) {
			/RETURN TRUE
		}
	/next i

	/RETURN FALSE
}

SUB getReadyMezSpell() {
	/declare i int local 

	/if (${autoMezSpell.Find[,]}==0) {
		/if (${isCastReady[${autoMezSpell}]}==FALSE) {
			/RETURN -
		} else {
			/RETURN ${autoMezSpell}
		}
	} else {
		/for i 1 to ${Math.Calc[${autoMezSpell.Count[,]}+1]}
			/if (${isCastReady[${autoMezSpell.Token[${i},,]}]}==TRUE) {
				/RETURN ${autoMezSpell.Token[${i},,]}
			}
		/next i
	}

	/RETURN -
}

SUB p3_autotrapdisarm_init() {
	/declare canDoAutoDisarm bool outer TRUE
	/declare checkAutoDisarmTimer timer outer

	/if (${Select[${Me.Class.ShortName},BRD,ROG]}==0) {
		/varset canDoAutoDisarm FALSE
		/return
	}

	/declare doAutoTrapDisarm bool outer FALSE
	/declare trapNames list outer

	/varset doAutoTrapDisarm ${getBotIniOption[Misc.AutoTrapDisarm,${doAutoTrapDisarm}]}


	/invoke ${trapNames.Append[DESERT CURSE,A BLADE,FESTERING OOZE,JAGGED BLADES,A DARK ENTITY,A SHIMMERING ORB,CAVE-IN]}
	/invoke ${trapNames.Append[A FORMLESS TERROR,A LOW HUM,A SINGULARITY,A WARDSTONE,A NULL FIELD,AN IMMOBILIZER,TRAP]}
	/invoke ${trapNames.Append[A PRESSURE PLATE,DECAYING REMAINS]}

	/RETURN
}


SUB autotrapdisarmMaintenance() {
	/if (${doAutoTrapDisarm}==FALSE) /RETURN
	/if (${canDoAutoDisarm}==FALSE) /RETURN
	/if (${checkAutoDisarmTimer}>0) /RETURN 

	/varset checkAutoDisarmTimer 5

	/if (${Me.AbilityReady[Sense Traps]}==TRUE) {
		/doability "sense traps"
		/delay 3
	}
	/if (${Me.AbilityReady[Disarm Traps]}==TRUE) /call checkAutoDisarm

	/RETURN
}


SUB checkAutoDisarm() {
   /declare i int local 0
   /declare j int local 1
   /declare tName string local
   /declare xspawn spawn local
   /declare nearbySpawnCount int local ${SpawnCount[radius 70]}

   /for i 0 to ${Math.Calc[${trapNames.Count}-1]}
      /varset tName ${trapNames.Item[${i}]}

      /for j 1 to ${nearbySpawnCount}
         /if (${NearestSpawn[${j},radius 70].ID}==NULL) /break
         /vardata xspawn NearestSpawn[${j},radius 70]

         /if (${xspawn.CleanName.Find[${tName}]}!=NULL) {
            /tar id ${xspawn.ID}
            /delay 3
            /doability "disarm traps"
            /delay 3
            /RETURN
         }
      /next j


		|/varset j 1
		|/while (1) {
		|   /if (${NearestSpawn[${j},radius 70].ID}==NULL) /break
		|
		|   /vardata xspawn NearestSpawn[${j},radius 70]
		|
		|   /if (${xspawn.CleanName.Find[${tName}]}!=NULL) {
		|      /tar id ${xspawn.ID}
		|      /delay 3
		|      /doability "disarm traps"
		|      /delay 3
		|      /RETURN
		|   }
		|
		|   /varset j ${Math.Calc[${j}+1]}
		|}

   /next i

   /RETURN
}

SUB p3_bardtwist_init {
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /RETURN

	/call p3RegisterCommand NEWTWIST bardtwistNewTwist 50

	/declare p3TwistEnabled bool outer true

	/declare notCastingTimer timer outer 30
	/declare doTwist bool outer TRUE

	/declare twistOrder string outer		1 2 3 4
	
	/varset twistOrder ${getBotIniOption[Bard.TwistOrder,${twistOrder}]}
	/varset p3TwistEnabled ${getBotIniOption[Bard.MacroControlledTwisting,${p3TwistEnabled}]}

	/RETURN
}


SUB bardtwistMaintenance {
	/if (${p3TwistEnabled}==FALSE) /RETURN

	/if (${Me.Class.ShortName.NotEqual[BRD]}) /RETURN

	/if (${Me.Casting.ID}!=NULL) /varset notCastingTimer 30

	/if (${notCastingTimer}==0) {
		/if (${Twist.Twisting}==FALSE && ${doTwist}==TRUE) {
			/echo do ${twistOrder}
			/twist ${twistOrder}
		}
	}

	/RETURN
}

SUB bardtwistNewTwist(string cmd, string opts) {
	/declare newOrder string local ${getStackCommandOpt[${opts},ORDER]}

	/if (${Cast.Effect.ID}!=NULL) {
		/twist off
		/delay 3
		/echo new twist start: ${newOrder}
		/twist ${newOrder}
		/delay 5
	}

	/varset twistOrder ${newOrder}

	/call writeBotIniOption Bard.TwistOrder "${newOrder}"
	/bc New twist: ${newOrder} (saved to ini)

	/RETURN
}

SUB p3_buffrequests_init {
	|WORKING VARS
	/declare buffQueue list outer
	/declare brOOMEmoteTimer timer outer 0
	/declare repeatBuffsQueue list outer
	/declare needsBuffPlayerQueue list outer 

	| INI DEFAULTS
	/declare brEnabled bool outer 				FALSE
	/declare brSameGuildOnly bool outer 		TRUE
	/declare brMinMana int outer 				25
	/declare brReplyViaTell bool outer 			TRUE
	/declare brDoEmotes bool outer 				TRUE

	| IMPORT INI
	/varset brEnabled 				${getBotIniOption[BuffRequestOptions.AcceptBuffRequests,${brEnabled}]}
	/varset brSameGuildOnly 		${getBotIniOption[BuffRequestOptions.SameGuildOnly,${brSameGuildOnly}]}
	/varset brMinMana				${getBotIniOption[BuffRequestOptions.MinimumMana,${brMinMana}]}
	/varset brReplyViaTell			${getBotIniOption[BuffRequestOptions.ReplyViaTell,${brReplyViaTell}]}
	/varset brDoEmotes				${getBotIniOption[BuffRequestOptions.DoEmotes,${brDoEmotes}]}

	/if (${iniBuffRequests[1,1].Equal[-]}) /varset brEnabled FALSE

	/RETURN
}


SUB buffrequestsMaintenance() {
	/if (${recentlyZoned}==TRUE) /return
	/if (${brEnabled}==TRUE) {
		/if (${Me.Invis}==TRUE) /return
		/if (${Me.Casting.ID}!=0) /return
		/if (${movingTimer}>0 && ${canCastWhileMoving}==FALSE) /return

		/call checkNeedsBuffsQueue
		/call checkBuffRequestQueue
		/call checkRepeatBuffsQueue
	}

	/RETURN
}


SUB checkNeedsBuffsQueue() {
	/if (${needsBuffPlayerQueue.Count}==0) /return
	/if (${buffQueue.Count}>0) /return

	/declare i int local
	/declare buffName string local
	/declare spawnID int local 
	/declare queueEntry string local
	/declare spellName string local
	/declare spawnName string local

	/varset spawnID ${Spawn[pc ${needsBuffPlayerQueue.Head[]}].ID}
	/varset spawnName ${Spawn[id ${spawnID}].CleanName}

	/call fullTarget ${spawnID}
	/if (${Macro.Return}==FALSE) /RETURN

	/for i 1 to ${iniBuffRequests.Size}
		/if (${iniBuffRequests[${i},1].Equal[-]}) /break

		/varset spellName ${iniBuffRequests[${i},1]}
		/varset queueEntry ${spawnID}_${spellName}_${i}

		/if (${Select[EMOTABLE,${iniBuffRequests[${i},${bKeyword}]},]}==0) /continue

		/if (${iniBuffRequests[${i},${bRequireTargetClass}].NotEqual[-]}) {
			/if (${Select[${Spawn[id ${spawnID}].Class.ShortName},${iniBuffRequests[${i},${bRequireTargetClass}]}]}==0) /continue
		}

		/if (${Target.Buff[${spellName}].ID}==NULL) {
			/invoke ${buffQueue.Append[${queueEntry}]}
		}

	/next i

	/RETURN
}

SUB checkBuffRequestQueue() {
	/declare e string local
	/declare targetID int local
	/declare buffName string local
	/declare createRecheckTimer bool local FALSE
	/declare ei int local
	/declare i int local
	/declare lockoutSecs int local

	/if (${buffQueue.Count}==0) /return

	/if (${Me.PctMana} < ${brMinMana} && ${buffQueue.Count}>0) {
		/if (${brOOMEmoteTimer}==0) {
			/em is low on mana and will continue buff requests later.
			/varset brOOMEmoteTimer 60s
		}
		/return
	}

	/for i 0 to ${Math.Calc[ ${buffQueue.Count}-1 ]}
		/varset e ${buffQueue.Item[${i}]}
		
		/varset targetID ${e.Token[1,_]}
		/varset buffName ${e.Token[2,_]}
		/varset ei ${e.Token[3,_]}
		/varset createRecheckTimer ${e.Token[4,_]}

		/if (${Spawn[pc id ${targetID}].ID}==NULL) {
			/invoke ${buffQueue.Erase[${i}]}
			/break
		}

		/if (${iniBuffRequests[${ei},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} < ${iniBuffRequests[${ei},${bSelfOverMana}]}) /continue
		}

		/if (${iniBuffRequests[${ei},${bMemInGem}].NotEqual[-]} && ${Me.Gem[${buffName}]}==NULL) {
			/call memorizeSpellInGem "${buffName}" ${iniBuffRequests[${ei},${bMemInGem}]}
		}

		/if (${isCastReady[${buffName}]}==FALSE) {
			/continue
		}

		/invoke (${cq.Append[CAST;SPELL=${buffName};TARGETID=${targetID};SRC=iniBuffRequests;SRCIDX=${ei};ONRESULT=onBuffRequestCastResult;BUFFQUEUEIDX=${i}]})

	/next i

	/RETURN
}

SUB onBuffRequestCastResult(string result, string opts) {
	/declare buffQueueIndex int local ${getStackCommandOpt[${opts},BUFFQUEUEIDX]}
	/declare buffIniIndex int local ${getStackCommandOpt[${opts},SRCIDX]}
	/declare lockoutSecs int local 0

	/declare targetID int local ${buffQueue.Item[${buffQueueIndex}].Token[1,_]}
	/declare buffName string local ${buffQueue.Item[${buffQueueIndex}].Token[2,_]}
	/declare repeatMode bool local ${buffQueue.Item[${buffQueueIndex}].Token[4,_]}

	/if (${result.Find[PASS_]}!=NULL || ${result.Find[FAIL_NOHOLD]}!=NULL) {
		/echo Buff request satisfied. Removing from queue.
		/invoke ${buffQueue.Erase[${buffQueueIndex}]}		

		/if (${repeatMode}==TRUE) {
			/varset lockoutSecs ${getSpellDurationByRequestName[${buffName}]}
			/if (${lockoutSecs}==0) /varset lockoutSecs 30
			/if (${lockoutSecs}>45) /varset lockoutSecs ${Math.Calc[${lockoutSecs}-12]}
			/call lockout "${targetID}_${buffIniIndex}" ${lockoutSecs}s
			/echo Locked out ${buffName} from repeat-buff queue for ${lockoutSecs}s.
		}


	} else {
		/echo Buff did not apply. Will leave in queue.
	}

	/RETURN
}

SUB checkRepeatBuffsQueue
	/declare i int local 
	/declare e string local
	/declare targetID int local
	/declare entryIndex int local
	/declare castRequest string local

	/if (${repeatBuffsQueue.Count}==0) /return

	/for i 0 to ${Math.Calc[ ${repeatBuffsQueue.Count}-1 ]}
		/varset e ${repeatBuffsQueue.Item[${i}]}
		/if (${isLockoutExpired[${e}]}==TRUE) {
			/varset targetID ${e.Token[1,_]}
			/varset entryIndex ${e.Token[2,_]}
			/varset castRequest ${iniBuffRequests[${entryIndex},1]}

			/if (${buffQueue.Index[${targetID}_${castRequest}_${entryIndex}_1]}>-1) /continue
			/invoke ${buffQueue.Append[${targetID}_${castRequest}_${entryIndex}_1]}
		}
	/next i
/RETURN

SUB p3_buffs_init {
	/declare updateNetnoteTimer timer outer 0
	/declare buffCheckTimer timer outer 30
	/declare buffsEnabled bool outer true
	/declare emptySpawn spawn outer

	/call processArrayTargets iniBuffs

	/declare canDoExtendedStackCheck bool outer TRUE

	/if (${Plugin[MQ2Dannet].Name.Length}==NULL) {
		/varset canDoExtendedStackCheck FALSE
	}
	
	/netnote

	/RETURN
}

SUB buffsMaintenance() {
	/if (${buffsEnabled}==FALSE) /return

	/call updateNetnoteBuffDurations

	/if (${Me.Invis}==TRUE) /return
	/if (${Stick.Active}==TRUE && ${combatStateTimer}==0) /return
	/if (${Me.Casting.ID} !=0 && ${Twist.Twisting}==FALSE) /return
	|/if ((${Me.Moving} || ${movingTimer}>0) && ${canCastWhileMoving}==FALSE) /return

	/call checkBuffs
	/RETURN
}

SUB updateNetnoteBuffDurations {
	/if (${updateNetnoteTimer}>0) /return
	/varset updateNetnoteTimer 5

	/declare i int local
	/declare buffDurations string local

	/for i 1 to 30
		/if (${Me.Buff[${i}].ID}==NULL) /continue
		/varset buffDurations ${buffDurations};${Me.Buff[${i}].Spell.ID}_${Me.Buff[${i}].Duration.TotalSeconds}
	/next i

	/for i 1 to 30
		/if (${Me.Song[${i}].ID}==NULL) /continue
		/varset buffDurations ${buffDurations};${Me.Song[${i}].Spell.ID}_${Me.Song[${i}].Duration.TotalSeconds}
	/next i

	/netnote ${buffDurations}

	/RETURN
}

SUB checkBuffs {
	/if (${buffCheckTimer}>0) /return
	/varset buffCheckTimer 15

	/declare i int local 
	/declare targetNames list local 
	/declare targetName string local
	/declare buffCastName string local
	/declare buffSpell spell local
	/declare buffSpellID int local
	/declare netbotName string local
	/declare checkSpellID int local 
	/declare buffSpawn spawn local
	/declare noholdTimerName string local
	/declare buffSpellRange int local
	/declare cancelCheck string local
	/declare note string local 
	/declare cancelConditions string local

	/declare j int local
	/declare k int local

	/for i 1 to ${iniBuffs.Size}
		/invoke ${targetNames.Clear}
		/if (${iniBuffs[${i},${bTargets}].Length}==0) /continue

		/if (${iniBuffs[${i},1].Equal[-]}) /break
		/if (${iniBuffs[${i},${bEnabled}].Equal[NO]}) /continue

		/if (${Me.Moving} || ${movingTimer}>0 && ${iniBuffs[${i},${bCastableMoving}].Equal[-]}) {
			/continue
		}

		/if (${combatStateTimer}>0) {
			/if (${iniBuffs[${i},${bCastableDuringAssist}].Equal[-]} && ${iniBuffs[${i},${bCastOnlyDuringAssist}].Equal[-]}) {
				/if (${combatStateTimer}>0) /continue
			}
		}

		/if (${iniBuffs[${i},${bGiftOfMana}].NotEqual[-]}) {
			/if (${Me.Song[Gift Of Mana].ID}==NULL) /continue
		}

		/if (${iniBuffs[${i},${bCastableOnlyResting}].NotEqual[-]}) {
			/if (${combatStateTimer}>0) /continue
		}

		/if (${iniBuffs[${i},${bCastOnlyDuringAssist}].NotEqual[-]}) {
			/if (${combatStateTimer}==0) /continue
		}

		/if (${iniBuffs[${i},${bNotIfAssistTag}].NotEqual[-]}) {
			/if (${tempCombatTags.Count}>0 || ${assistTags.Count}>0) {
				/call validateAssistTags ${iniBuffs[${i},${bNotIfAssistTag}]} TRUE
				/if (${Macro.Return}==TRUE) /continue
			}
		}

		/if (${iniBuffs[${i},${bRequireAssistTag}].NotEqual[-]}) {
			/if (${tempCombatTags.Count}==0 && ${assistTags.Count}==0) /continue
			/call validateAssistTags ${iniBuffs[${i},${bRequireAssistTag}]}
			/if (${Macro.Return}==FALSE) /continue
		}

		/if (${iniBuffs[${i},${bMyName}].NotEqual[-]}) {
			/if (${Me.CleanName.Upper.NotEqual[${iniBuffs[${i},${bMyName}].Upper}]}) /continue
		}
		/if (${iniBuffs[${i},${bNotIfMounted}].NotEqual[-]}) {
			/if (${Me.Mount.ID}!=NULL) /continue
		}
		/if (${iniBuffs[${i},${bRequireCastIdle}].NotEqual[-]}) {
			/if (${idleCastingTimer}>0) /continue
		}
		/if (${iniBuffs[${i},${bRequireAssistTarget}].NotEqual[-]}) {
			/if (${assistSpawnID}==0) /continue
		}
		/if (${iniBuffs[${i},${bSelfOverHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} < ${iniBuffs[${i},${bSelfOverHP}]}) /continue
		}
		/if (${iniBuffs[${i},${bSelfUnderHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} >= ${iniBuffs[${i},${bSelfUnderHP}]}) /continue
		}
		/if (${iniBuffs[${i},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} < ${iniBuffs[${i},${bSelfOverMana}]}) /continue
		}
		/if (${iniBuffs[${i},${bSelfUnderMana}].NotEqual[-]}) {
			/if (${Me.PctMana} >= ${iniBuffs[${i},${bSelfUnderMana}]}) /continue
		}
		/if (${iniBuffs[${i},${bSelfUnderEnd}].NotEqual[-]}) {
			/if (${Me.PctEndurance} >= ${iniBuffs[${i},${bSelfUnderEnd}]} ) /continue
		}
		/if (${iniBuffs[${i},${bSelfOverEnd}].NotEqual[-]}) {
			/if (${Me.PctEndurance} < ${iniBuffs[${i},${bSelfUnderEnd}]} ) /continue
		}
		/if (${iniBuffs[${i},${bRequireMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 45]} < ${iniBuffs[${i},${bRequireMobsInProximity}]}) /continue
		}
		/if (${iniBuffs[${i},${bRequireUW}].NotEqual[-]}) {
			/if (${Me.FeetWet}==FALSE) /continue
		}

		| OBTAIN BUFF SPELL DETAIL
		/varset buffCastName ${iniBuffs[${i},${bName}]}

		/call getSpellFromCastRequest "${buffCastName}"
		/if (${Macro.Return.Equal[UNKNOWN]}) {
			/bc Warning: checkBuffs() getSpellFromCastRequest() returned UNKNOWN for ${iniBuffs[${i},${bName}]}. Not sure what to do. Disabling entry.
			/varset iniBuffs[${i},${bEnabled}] NO
			/RETURN
		} else {
			/vardata buffSpell ${Macro.Return}
		}

		/varset buffSpellID ${buffSpell.ID}
		
		/if (${iniBuffs[${i},${bForceSpellID}].NotEqual[-]}) {
			/varset buffSpellID ${iniBuffs[${i},${bForceSpellID}]}
		}

		/if (${isLockoutExpired[bufflockout_${buffSpellID}]}==FALSE) /CONTINUE

		/if (${iniBuffs[${i},${bIgnoreTargetType}].Equal[-]}) {
			/if (${buffSpell.TargetType.Equal[Pet]} || ${iniBuffs[${i},${bTargetType}].Upper.Equal[PET]} ) {
				/if (${Me.Pet.ID}==NULL) /continue
				/if (${Me.PetBuff[${buffSpell.Name}]}!=NULL) /continue
				/invoke ${targetNames.Append[${Me.Pet.Name}]}
				/goto :skipNetBots
			} else /if (${buffSpell.TargetType.Equal[Self]}) {
				/invoke ${targetNames.Append[${Me.CleanName}]}
			} else {
				/invoke ${targetNames.Append[${iniBuffs[${i},${bTargets}]}]}
			}
		} else {
			/invoke ${targetNames.Append[${iniBuffs[${i},${bTargets}]}]}
		}

		/if (${buffSpell.TargetType.Equal[Group v1]}) /varset buffSpellRange ${buffSpell.AERange}
		/if (${buffSpell.TargetType.Equal[Group v2]}) /varset buffSpellRange ${buffSpell.AERange}
		/if (${buffSpell.TargetType.Equal[Single]}) /varset buffSpellRange ${buffSpell.MyRange}
		/if (${buffSpell.TargetType.Equal[Self]} && ${iniBuffs[${i},${bIgnoreTargetType}].NotEqual[-]}) /varset buffSpellRange 50

		| TARGETNAMES ARE ALL POSSIBLE TARGETS REGARDLESS OF WHETHER OR NOT THEY HAVE THE BUFF.
		| THIS LOOP REMOVES PEOPLE WHO DONT QUALIFY FOR A CAST, TYPICALLY BECAUSE THEY HAVE THE
		| BUFF. BUFF ENTRIES WITH REBUFFSECONDS MAY KEEP PEOPLE IN THE LIST WHO ALREADY HAVE
		| THE BUFF IF THE TIME ON THE BUFF IS LOW ENOUGH.

		/for j ${Math.Calc[${targetNames.Count}-1]} downto 0
			/varset targetName ${targetNames.Item[${j}]}
			/if (${targetName.Length}==0) /continue

			/if (${Spawn[${targetName}].ID}==NULL) {
				/invoke ${targetNames.Remove[${targetName}]}
				/continue
			}

			/if (${NetBots[${targetName}].State.Equal[DEAD]}) /continue


			|/echo ${targetName} ${iniBuffs[1,1]}

			| HAVE THE BUFF?
			/if (${Select[${buffSpellID},${NetBots[${targetName}].Buff}]}>0 || ${Select[${buffSpellID},${NetBots[${targetName}].ShortBuff}]}>0) {

				| REBUFF SECONDS DONT MATER? REMOVE THIS PERSON FROM BUFF CANDIDATES
				/if (${iniBuffs[${i},${bRebuffSeconds}].Equal[-]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}

				| REBUFFSECONDS ENTRY PRESENT, EXAMINE NETNOTE

				| EMPTY NETNOTE.  REMOVE FROM CANDIDATES SINCE THEY HAVE THE BUFF
				/if (${NetBots[${targetName}].Note.Length}==0) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}

				| NO NETNOTE FOR SPELL FOUND - ASSUME PERSON NEEDS BUFF - LEAVE THEM IN LIST

				/if (${NetBots[${targetName}].Note.Find[;${buffSpellID}_]}==NULL) /continue
				
				| NETNOTE FOR SPELLID EXISTS, CHECK
				/varset note ${NetBots[${targetName}].Note}
				/varset note ${note.Right[ -${note.Find[;${buffSpellID}_]} ]}

				| REMAINING BUFF TIME IS SUFFICIENT, REMOVE PLAYER FROM BUFF CANDIDATES
				/if (${note.Token[1,;].Token[2,_]} > ${iniBuffs[${i},${bRebuffSeconds}]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}

				| REMAINING TIME IS NOT SUFFICIENT, LEAVE THEM IN THE LIST BY DOING NOTHING
			}

			|/if (${Select[${buffSpellID},${NetBots[${targetName}].ShortBuff}]}>0) {
			|	/invoke ${targetNames.Remove[${targetName}]}
			|	/continue
			|}

			/if (${NetBots[${targetName}].InZone}==FALSE) { 
				/invoke ${targetNames.Remove[${targetName}]}
				/continue
			}

			/if (${iniBuffs[${i},${bExtendedStackCheck}].NotEqual[-]} && ${canDoExtendedStackCheck}==TRUE) {
				/dquery ${targetName} -q "Spell[${buffSpell}].Stacks" 
				/if (${DanNet.Q}==FALSE) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bRequireGroupInRange}].NotEqual[-]}) {
				/if (${targetName.NotEqual[${Me.CleanName}]} && ${Group.Member[${targetName}].Index}==NULL) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}

				/if (${Spawn[pc ${targetName}].Distance3D} > ${buffSpellRange}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bTargetUnderHP}].NotEqual[-]}) {
				/if (${NetBots[${targetName}].PctHPs} > ${iniBuffs[${i},${bTargetUnderHP}]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bTargetOverHP}].NotEqual[-]}) {
				/if (${NetBots[${targetName}].PctHPs} <= ${iniBuffs[${i},${bTargetOverHP}]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bNotIfShortBuff}].NotEqual[-]}) {
				/varset checkSpellID ${Spell[${iniBuffs[${i},${bNotIfShortBuff}]}].ID}
				/if (${Select[${checkSpellID},${NetBots[${targetName}].ShortBuff}]}>0) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bNotIfLongBuff}].NotEqual[-]}) {
				/varset checkSpellID ${Spell[${iniBuffs[${i},${bNotIfLongBuff}]}].ID}
				/if (${Select[${checkSpellID},${NetBots[${targetName}].Buff}]}>0) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bTargetOverLevel}].NotEqual[-]}) {
				/if (${NetBots[${targetName}].Level} < ${iniBuffs[${i},${bTargetOverLevel}]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${iniBuffs[${i},${bTargetUnderLevel}].NotEqual[-]}) {
				/if (${NetBots[${targetName}].Level} >= ${iniBuffs[${i},${bTargetUnderLevel}]}) {
					/invoke ${targetNames.Remove[${targetName}]}
					/continue
				}
			}

			/if (${Spawn[pc ${targetName}].Distance3D} > ${buffSpellRange}) {
				/invoke ${targetNames.Remove[${targetName}]}
				/continue
			}
		/next j


		/if (${targetNames.Count}==0) {
			/if (${iniBuffs[${i},${bRevertToBandolier}].NotEqual[-]}) {
				/if (${bandolierProfileIsActive[${iniBuffs[${i},${bRevertToBandolier}]}]}==FALSE) {
					/band activate ${iniBuffs[${i},${bRevertToBandolier}]}
				}
			}
			/continue
		}

		/if (${iniBuffs[${i},${bActivateBandolier}].NotEqual[-]}) {
			/if (${bandolierProfileIsActive[${iniBuffs[${i},${bActivateBandolier}]}]}==FALSE) {
				/band activate ${iniBuffs[${i},${bActivateBandolier}]}
			}
		}

		/if (${iniBuffs[${i},${bRequireGroupInRange}].NotEqual[-]}) {
			/for k 1 to ${Group.Members}
				/if (${Spawn[group =${Group.Member[${k}]}].ID}==NULL) /continue
				/if (${Spawn[group =${k}].Distance3D} > ${buffSpellRange}) /continue
			/next k
		}

		:skipNetBots

		/if (${iniBuffs[${i},${bUseTeamIndex}].NotEqual[-]}) {
			/if (${targetNames.Count}<${teamIndex}) /continue
			/if (${Spawn[pc ${targetNames.Item[${teamIndex}]}].ID}==NULL) /continue
			/vardata buffSpawn Spawn[pc ${targetNames.Item[${teamIndex}]}]
		} else {

			/if (${iniBuffs[${i},${bTargetType}].Upper.Equal[PET]}) {
				/vardata buffSpawn Spawn[pcpet ${targetNames.Item[0]}]
			} else {
				/vardata buffSpawn emptySpawn
				/for k 0 to ${Math.Calc[${targetNames.Count}-1]}
					/vardata buffSpawn Spawn[pc ${targetNames.Item[${k}]}]
					/if (${isLockoutExpired[noHoldTimer_${buffSpawn.ID}_${buffSpellID}]}==TRUE) /break
				/next k
			}
		}

		/if (${buffSpawn.ID}==NULL) /continue
		/if (${isLockoutExpired[noHoldTimer_${buffSpawn.ID}_${buffSpellID}]}==FALSE) /continue

		/if (${iniBuffs[${i},${bNoCast}].NotEqual[-]}) /continue

		/if (${iniBuffs[${i},${bMemInGem}].NotEqual[-]} && ${Me.Gem[${buffCastName}]}==NULL) {
			/call memorizeSpellInGem "${buffCastName}" ${iniBuffs[${i},${bMemInGem}]}
			/if (${Macro.Return}==FALSE) {
				/varset iniBuffs[${i},${bEnabled}] NO
				/continue
			}
		}

		/if (${isCastReady[${buffCastName}]}==FALSE) {
			/continue
		}
		
		/if (${iniBuffs[${i},${bDoCommand}].NotEqual[-]}) {
			/docommand ${iniBuffs[${i},${bDoCommand}]}
			/delay 3
		}

		/invoke (${cq.Append[CAST;SPELL=${buffCastName};TARGETID=${buffSpawn.ID};BUFFSPELLID=${buffSpellID};CANCELCONDITIONS=${cancelConditions};SRC=iniBuffs;SRCIDX=${i};ONRESULT=onBuffCastResult]})

		/varset buffCheckTimer 15
		/break

	/next i

	/RETURN
}

SUB onBuffCastResult(string result, string opts) {
	/echo BuffCR: ${result} ${opts}

	/declare i int local ${getStackCommandOpt[${opts},SRCIDX]}
	/declare targetID int local ${getStackCommandOpt[${opts},TARGETID]}
	/declare buffSpellID ${getStackCommandOpt[${opts},BUFFSPELLID]}
	/declare targetName string ${Spawn[id ${targetID}]}

	/if (${NetBots[${targetName}].ID}!=NULL) {
		/bct ${targetName} //netnote
	}

	/if (${iniBuffs[${i},${bNoSitTimer}].NotEqual[-]}) {
		/call pauseAutoMed ${iniBuffs[${i},${bNoSitTimer}]}
	}

	/if (${result.Equal[FAIL_NOHOLD]}==TRUE) {
		/echo Spell did not take hold. Locking out buff ${Spell[${buffSpellID}]} for 5m.
		/call lockout noHoldTimer_${targetID}_${buffSpellID} 5m
	}

	/if (${iniBuffs[${i},${bRecastDelay}].NotEqual[-]}) {
		/call lockout bufflockout_${buffSpellID} ${iniBuffs[${i},${bRecastDelay}]}
		/echo Buff recast requested. Locking out buff ${Spell[${buffSpellID}]} for ${iniBuffs[${i},${bRecastDelay}]}.
	}

	/if (${result.Equal.Equal[PASS_CAST_SUCCESS]}) {
		/if (${NetBots[${Spawn[id ${targetID}].CleanName}].Level}!=NULL) {
			/bc tell ${NetBots[${Spawn[id ${targetID}].CleanName} NETNOTE
			/squelch /bct ${targetName} //netnote
		}
	}


	/RETURN
}

SUB p3_camp_init {
	/call p3RegisterCommand FOLLOW campFollow 50
	/call p3RegisterCommand ROAMLOCK campRoamStarted 55
	/call p3RegisterCommand CAMPON campCampOn 20

	/declare campCheckTimer timer outer 
	/declare campEnabled bool outer FALSE
	/declare campStartZoneID int outer 
	/declare campX int outer
	/declare campY int outer
	/declare campZ int outer
	/declare campSpawnID int outer 0

	/RETURN
}

SUB campRoamStarted(string cmd, string opts) {
	/if (${campEnabled}==TRUE) {
		/varset campEnabled FALSE
		/bc Camp disabled to allow roam.
	}
	/RETURN
}

SUB campFollow(string cmd, string opts) {
	/if (${campEnabled}==TRUE) {
		/varset campEnabled FALSE
		/bc Camp disabled to engage follow.
	}
	/RETURN
}

SUB campCampOff(string cmd, string opts) {
	/declare sourceName string local ${getStackCommandOpt[${opts},SOURCENAME]}
	/if (${Spawn[=${sourceName}].ID}==NULL) /RETURN

	/if (${campEnabled}==TRUE) {
		/varset campEnabled FALSE
		/bc Camp mode disabled.
	}
	/RETURN
}

SUB campCampOn(string cmd, string opts) {
	/declare campType string local ${getStackCommandOpt[${opts},TYPE]}
	/declare spawnTargetID int local
	/declare sourceName string local

	/if (${campType.Equal[SPAWN]}) {
		/varset spawnTargetID ${getStackCommandOpt[${opts},SPAWNTARGETID]}
		/if (${Spawn[id ${spawnTargetID}].ID}==NULL) /RETURN RESET

		/bc Using spawn ${Spawn[id ${spawnTargetID}]} as camp location.
		/varset campSpawnID ${spawnTargetID}
		/varset campEnabled TRUE
		/varset campStartZoneID ${Zone.ID}
	}

	/if (${campType.Equal[LOC]}) {
		/varset sourceName ${getStackCommandOpt[${opts},SOURCENAME]}
		/if (${Spawn[=${sourceName}].ID}==NULL) /RETURN RESET

		/varset campSpawnID 0
		/varset campX ${Spawn[${sourceName}].X}
		/varset campY ${Spawn[${sourceName}].Y}
		/varset campZ ${Spawn[${sourceName}].Z}
		/varset campEnabled TRUE
		/varset campStartZoneID ${Zone.ID}
		/bc Now camping at ${sourceName}'s location.
	}

	/RETURN
}


SUB campMaintenance() {
	/if (${campEnabled}==TRUE) /call checkCamp
	/RETURN
}

SUB checkCamp() {
	/if (${campCheckTimer}>0) /RETURN
	/if (${Me.Moving}==TRUE) /return
	/varset campCheckTimer 5
	
	/if (${Zone.ID}!=${campStartZoneID}) {
		/call stopCamping
		/return
	}

	/if (${Stick.Active}==TRUE || ${Navigation.Active}==TRUE) /RETURN
	/if (${combatStateTimer}>0) /RETURN

	/if (${campSpawnID}!=0) {
		/varset campX ${Spawn[id ${campSpawnID}].X}
		/varset campY ${Spawn[id ${campSpawnID}].Y}
		/varset campZ ${Spawn[id ${campSpawnID}].Z}
	}

	/if (${Math.Distance[${campY}, ${campX}, ${campZ}]}>15) {
		/if (${Navigation.MeshLoaded}==TRUE && ${Navigation.Active}==FALSE && ) {
			/bc Returning to camp.
			/nav locxyz ${campX} ${campY} ${campZ}
		} else {
			/moveto dist 15
			/moveto loc ${campY} ${campX}
		}
	} else {

	}
	/RETURN
}


SUB stopCamping() {
	/if (${campEnabled}==TRUE) {
		/varset campEnabled FALSE
		/bc Camp mode disabled.
	}
	/RETURN
}

SUB p3_casting_init {
	/call p3RegisterCommand FOLLOW castingFollow 52
	/call p3RegisterCommand STOP castingStop 52
	/call p3RegisterCommand CAST castingCast 50

	/declare castingSpell spell outer
	/declare castingOpts string outer -
	/declare castingTargetID int outer 0
	/declare castingCancelConditions list outer
	/invoke ${castingCancelConditions.Delimiter[|]}

	/declare castingSpellEmpty spell outer
	/declare untrackedCastSpell spell outer

	/declare castResult string outer -

	/declare idleCastingTimerMax int outer 50
	/declare idleCastingTimer timer outer 0

	/declare cancelConditionDelay timer outer 0

	/RETURN
}

SUB castingSetIdle() {
	/if (${castingSpell.ID}!=0) {
		/vardata castingSpell castingSpellEmpty
		/varset castingOpts -
		/varset castResult -
		/varset castingTargetID 0
		/invoke ${castingCancelConditions.Clear}
	}

	/RETURN
}

SUB castingFollow(string cmd, string opts) {
	/if (${Me.Casting.ID} != NULL && ${Me.Class.ShortName.Equal[BRD]}==FALSE) {
		/echo stop for casting follow
		/varset movingTimer 20
		/interrupt
		/delay 5
	}
	/RETURN
}

SUB castingStop(string cmd, string opts) {
	/if (${Me.Casting.ID}!=NULL && ${amBard}==FALSE) {
		/echo stop cast seen.
		/interrupt
	}
	/RETURN
}

SUB castingCast(string cmd, string opts) {
	/call p3cast ${getStackCommandOpt[${opts},TARGETID]} "${getStackCommandOpt[${opts},SPELL]}" "${getStackCommandOpt[${opts},SRC]}" ${getStackCommandOpt[${opts},SRCIDX]}

	/varset castingOpts ${opts}
	/echo ret: ${Macro.Return}  ${opts}

	/if (${Macro.Return.Equal[PASS_STARTED]}) {
		/vardata castingSpell ${getSpellFromCastRequest[${getStackCommandOpt[${castingOpts},SPELL]}]}

		/vardata untrackedCastSpell castingSpellEmpty
		/varset castingTargetID ${getStackCommandOpt[${castingOpts},TARGETID]}
		/invoke ${castingCancelConditions.Append[${getStackCommandOpt[${castingOpts},CANCELCONDITIONS]}]}
		/echo Cast Started: [${castingSpell}].

	} else /if (${Macro.Return.Equal[PASS_INSTANT_CAST]}) {
		/echo Instant cast done: [${getStackCommandOpt[${opts},SPELL]}]
		/vardata castingSpell ${getSpellFromCastRequest[${getStackCommandOpt[${castingOpts},SPELL]}]}
		/call castComplete ${castResult}

	} else /if (${Macro.Return.Equal[PASS_ABILITY_DONE]}) {
		/echo Ability Used: [${getStackCommandOpt[${opts},SPELL]}].

	} else /if (${Macro.Return.Equal[FAIL_ABILITY_NOT_READY]}) {
		/echo Ability Not Ready: [${getStackCommandOpt[${opts},SPELL]}].

	} else /if (${Macro.Return.Find[FAIL_LOS]}!=NULL) {
		/echo Couldn't cast. No line of sight.

	} else /if (${Macro.Return.Find[FAIL_]}!=NULL) {
		/echo Cast didn't start [${castingOpts}] => ${Macro.Return}

	}

	/RETURN
}

SUB castingMaintenance() {
	/declare sourceArr string local
	/declare i int local

	/if (${Twist.Twisting}==TRUE && ${Me.Casting.ID}==${castingSpell.ID} && ${castingSpell.ID}!=0) {
		/if (${Cast.Timing}==0) {
			/twist off
		}
		/RETURN RESET
	}

	/if (${Me.Casting.ID}!=NULL) {
		/if (${idleCastingTimer}<40) /varset idleCastingTimer ${idleCastingTimerMax}

		|/if (${movingTimer}>0 && ${canCastWhileMoving}==FALSE) {
		|	/echo Movement detected. Stopping cast.
		|	/interrupt
		|	/delay 3
		|	/return
		|}

		/if (${Me.Casting.ID} != ${castingSpell.ID}) {
			/vardata untrackedCastSpell Me.Casting
			|/echo Unknown Cast In Progress [${untrackedCastSpell}].
			/if (${castResult.Equal[IDLE]}) /varset castResult STARTED
			/call castingSetIdle
		} else {
			|/echo Casting ${castingSpell} as expected... CC: ${getStackCommandOpt[${castingOpts},CANCELCONDITIONS]}
			/varset buffCheckTimer 10
			/if (${castingTargetID}==${Target.ID}) {
				/call checkCancelConditions

				/if (${Macro.Return}==TRUE) {
					/BC Cancel Conditions met: [${getStackCommandOpt[${castingOpts},CANCELCONDITIONS]}]
					/interrupt
					/delay 3
					/call castingSetIdle
					/RETURN RESET
				}
			}
		}

		/if (${amBard}==FALSE) /RETURN RESET
	}

	/if (${Me.Casting.ID}==NULL) {
		/if (${castingSpell.ID} != NULL) {
			/echo Detected end of cast for [${castingSpell}]
			
			/varset sourceArr ${getStackCommandOpt[${castingOpts},SRC]}
			/varset i ${getStackCommandOpt[${castingOpts},SRCIDX]}

			/if (${castResult.Equal[-]}) {
				| DIDN'T CATCH A CAST RESULT - NOTHING TO DO
				/BC Woops - Didn't catch a cast result.
				/em is confused.
				/RETURN
			}

			/if (${castResult.Equal[STARTED]}) /varset castResult SUCCESS

			/if (${${sourceArr}[${i},${bAssumeSuccess}].NotEqual[-]}) {
				/echo Assuming Success: on ${${sourceArr}[${i},${bName}].Equal[-]}
				/varset castResult SUCCESS
			} else {
				| PROCESS CHAT EVENTS TO MAKE SURE RESISTS AND SUCH GET REGISTERED
				/doevents
				/delay 5
			}
			
			/if (${${sourceArr}[${i},${bNoSitTimer}].NotEqual[-]}) {
				/echo Pausing medbreak: ${${sourceArr}[${i},${bNoSitTimer}]}
				/call pauseAutoMed ${${sourceArr}[${i},${bNoSitTimer}]}
			}
		
			/if (${castResult.Equal[SUCCESS]} || ${${sourceArr}[${i},${bAssumeSuccess}].NotEqual[-]}) {
				/call castComplete PASS_${castResult}
			} else {
				/call castComplete FAIL_${castResult}
			}

			/varset castResult -

			/RETURN
		}

		/if (${untrackedCastSpell.ID}!=NULL) {
			/echo Detected end of unknown cast.
			/vardata untrackedCastSpell castingSpellEmpty
		}
	}

	
	/RETURN
}

SUB checkCancelConditions() {
	/declare i int local
	/declare e string local

	/for i 0 to ${Math.Calc[${castingCancelConditions.Count}-1]}
		/varset e ${castingCancelConditions.Item[${i}]}

		/if (${e.Find[TARGETDEAD]}!=NULL) {
			/if (${Target.Dead}==TRUE) /return TRUE
		}

		/if (${e.Find[TARGETISASSITTARGET]}!=NULL) {
			/if (${assistSpawnID}==${Target.ID}) /return TRUE
		}

		/if (${e.Find[TARGETUNDERHP]}!=NULL) {
			/if (${Target.PctHPs} < ${Math.Calc[${e.Token[2,:]}]}) {
				/return TRUE
			}
		}

		/if (${e.Find[TARGETOVERHP]}!=NULL) {
			/if (${NetBots[${Target.Name}].ID}!=NULL) {
				/if (${NetBots[${Target.Name}].PctHPs} > ${Math.Calc[${e.Token[2,:]}]}) /return TRUE
			} else {
				/if (${Target.PctHPs} > ${Math.Calc[${e.Token[2,:]}]}) /return TRUE
			}
		}

		/if (${e.Find[TARGETHASBUFF]}!=NULL) {
			/if (${Target.Buff[${e.Token[2,:]}].ID}!=NULL) /return TRUE
		}

		/if (${e.Find[NETBOTATTACKING]}!=NULL) {
			/if (${isNetBotAttackingID[${e.Token[2,:]}]}==TRUE) /return TRUE
		}
	/next i

	/RETURN FALSE
}

SUB p3Cast(int targetID, string castName, string arrName, int arrIdx) {
	/declare castType string local
	/declare castSpell spell local
	/declare bardWasTwisting bool local FALSE
	/declare ret string local
	/declare hasCastTime bool local TRUE

	/call getCastTypeByCastRequest "${castName}"
	/if (${Macro.Return.Equal[UNKNOWN]}) /RETURN FAIL_UNKNOWN_SPELL
	/varset castType ${Macro.Return}


	| CHECK ABILITIES AND HANDLE RIGHT AWAY SINCE THEY DONT HAVE "SPELLS" 
	/if (${castType.Equal[ABILITY]}) /varset hasCastTime FALSE

	| ALL OTHER CAST TYPES INVOLVE SPELLS
	/call getSpellFromCastRequest "${castName}"

	/if (${Macro.Return.Equal[UNKNOWN]}) {
		/vardata castSpell castingSpellEmpty

	} else /if (${Macro.Return.NotEqual[ABILITY]}) {
		/vardata castSpell ${Macro.Return}
		/if (${Spawn[id ${targetID}].LineOfSight}==FALSE && ${castSpell.SpellType.Find[Detri]}) /RETURN FAIL_LOS
	}

	/if (${isCastReady[${castName}]}==FALSE) {
		/if (${castType.Equal[ABILITY]}) {
			/RETURN FAIL_ABILITY_NOT_READY
		}

		/vardata castSpell castingSpellEmpty
		/RETURN FAIL_CAST_NOT_READY
	}

	/if (${castType.Equal[ALTABILITY]} && ${AltAbility[${castName}].Spell.CastTime}==0) /varset hasCastTime FALSE
	/if (${castType.Equal[ITEM]} && ${FindItem[=${castName}].CastTime}==0) /varset hasCastTime FALSE
	/if (${castType.Equal[ABILITY]}) /varset hasCastTime FALSE
	/if (${castType.Equal[DISCIPLINE]}) {
		/if (${Spell[${castName}].MyCastTime} != NULL && ${Spell[${castName}].MyCastTime}>0) {
			/echo has cast time: ${Spell[${castName}]}
			/varset hasCastTime TRUE
		} else {
			/varset hasCastTime FALSE
		}
	}

	/echo Casting/Doing [${castName}] => ${Spawn[id ${targetID}].CleanName}

	/if (${hasCastTime}==TRUE) {
		/if (${canCastWhileMoving}==FALSE) {
			/call movementLockoutStick 15
		}

		/if (${Twist.Twisting}==TRUE) {
			/twist stop
			/delay 3
		}
	}

	/varset castResult STARTED

	/if (${castType.Equal[ABILITY]}) {
		/doability ${Me.Ability[${castName}]}
		/RETURN PASS_ABILITY_DONE	

	} else /if (${castType.Equal[DISCIPLINE]}) {
		/disc ${castName}

		/if (${hasCastTime}==TRUE) /RETURN PASS_STARTED
		/if (${hasCastTime}==FALSE) /RETURN PASS_INSTANT_CAST
	} else /if (${castType.Equal[ALTABILITY]}) {
		/alt act ${AltAbility[${castName}].ID}
		/if (${hasCastTime}==FALSE) /RETURN PASS_INSTANT_CAST
	} else /if (${castType.Equal[ITEM]}) {
		|/useitem "${castName}"
		/itemnotify "${castName}" rightmouseup
		/delay 5
		/if (${hasCastTime}==FALSE) /RETURN PASS_INSTANT_CAST
	} else /if (${castType.Equal[SPELL]}) {
		/if (${Me.Class.ShortName.Equal[BRD]} && ${castType.Equal[SPELL]}) {
			|/CAST ${Me.Gem[${castName}]}
			/twist once ${Me.Gem[${castName}]}
		} else {
			/cast ${Me.Gem[${castName}]}
		}
	}

	/delay 5

	/varset ret PASS_STARTED

	/RETURN ${ret}
}

SUB castComplete(string result) {
	/varset buffCheckTimer 10
	/declare funcName string local
	/declare i int local ${getStackCommandOpt[${castingOpts},SRCIDX]}
	/declare cSpellName string local ${getStackCommandOpt[${castingOpts},SPELL]}
	/declare recastDelayTimerName string local
	/declare targetDurationTimerName string local
	/declare cSpell spell local
	/declare targetID string local ${getStackCommandOpt[${castingOpts},TARGETID]}
	/declare trackRecast string local ${getStackCommandOpt[${castingOpts},TRACKRECAST]}

	/BC ${result} -> ${castingSpell} ${Spawn[id ${targetID}]}

	/call getSpellFromCastRequest "${cSpellName}"
	/vardata cSpell ${Macro.Return}

	/varset recastDelayTimerName detriTimer_${cSpell.ID}
	/varset targetDurationTimerName detriTimer_${targetID}_${cSpell.ID}

	/if (${result.Find[FAIL_NOHOLD]}!=NULL) {
		/call lockout ${recastDelayTimerName} 120

	} else /if (${result.Find[PASS_]}!=NULL) {
		/if (${iniCombatSpells[${i},${bNoSitTimer}].NotEqual[-]}) {
			/call pauseAutoMed ${iniCombatSpells[${i},${bNoSitTimer}]}
		}

		/if (${iniCombatSpells[${i},${bRecastDelay}].NotEqual[-]}) {
			/call lockout ${recastDelayTimerName} ${iniCombatSpells[${i},${bRecastDelay}]}
		}

		/if (${cSpell.Duration.TotalSeconds}>0) {
			/call lockout ${targetDurationTimerName} ${Math.Calc[${cSpell.Duration.TotalSeconds}*10]}
		}

	} else /if (${result.Equal[FAIL_RESIST]}) {
		|/varset currentResistCount ${Math.Calc[${currentResistCount}+1]}
		|/bc Cast Attempts: ${currentResistCount} of ${maxResists}
		|/if (${currentResistCount}<${maxResists}) {
		|	/while (${isCastReady[${cSpellName}]}==FALSE) {
		|		/delay 2
		|	}
		|	/goto :resistRetry
		|}
		|
		|/if (${currentResistCount}==${maxResists}) {
		|	/bc My spell was resisted too much.  Giving up...
		|	/g Giving up casting ${cSpellName} on ${spellKillID}, too many resists.
		|	/declare ${recastDelayTimerName} timer outer 5m
		|}
	} else /if (${result.Equal[FAIL_IMMUNE]}) {
		/bc Immune.  Giving up...
		/g Giving up casting ${cSpellName} on ${spellKillID}, target is immune.
		/call lockout ${recastDelayTimerName} 5m
	}

	/varset funcName ${getStackCommandOpt[${castingOpts},ONRESULT]}

	/if (${funcName.Equal[-]}) {
		/call castingSetIdle
	} else {
		/call ${funcName} ${result} "${castingOpts}"
		/call castingSetIdle
	}

	/RETURN
}
SUB p3_castorders_init() {
	/declare adhocCastListCheckTimer timer outer 0
	/declare adhocCastList list outer 
	/declare adHocCastPendingTimer timer outer 0

	/RETURN
}


SUB castordersMaintenance() {
	/if (${adhocCastList.Count}>0 && ${adHocCastPendingTimer}==0) {
		/call checkAdhocCastList
	}

	/RETURN ${Macro.Return}
}

SUB addCastOrder(string castName, string castTarget, bool trackRecastDuration) {
	/varset castName ${castName.Upper}

	/declare i int local
	/declare botName string local
	/declare botID int local
	/declare spellID int local
	/declare castSpell spell local

	/if (${castTarget.Upper.Equal[ALL]}) {
		/for i 1 to ${NetBots.Counts}
			/varset botName ${NetBots.Client[${i}]}
			/varset botID ${NetBots[${botName}].ID}
			/if (${adhocCastList.Contains[${castName}_${botID}]}==TRUE) /continue
			/invoke (${adhocCastList.Append[${castName}_${botID}]})
		/next i
	} else /if (${castTarget.Upper.Equal[SELF]}) {
		/if (${adhocCastList.Contains[${castName}_${Me.ID}]}==TRUE) {
			/bc Already have a cast request for ${castName} for ${Me.CleanName}
			/return
		}
		/invoke ${adhocCastList.Append[${castName}_${Me.ID}]}
	} else /if (${Spawn["${castTarget}"].ID}!=NULL) {
		/if (${adhocCastList.Contains[${castName}_${Spawn["${castTarget}"].ID}]}==TRUE) {
			/bc Already have a cast request for ${castName} for ${Spawn["${castTarget}"].CleanName}
			/return
		}
		/invoke ${adhocCastList.Append[${castName}_${Spawn["${castTarget}"].ID}_${If[${trackRecastDuration},1,0]}]}
	}
 
	/RETURN
}



SUB checkAdhocCastList() {
	/if (${adhocCastListCheckTimer}>0) /return
	/varset adhocCastListCheckTimer 3

	/declare i int local
	/declare castName string local
	/declare targetID string local
	/declare trackRecast string local
	/declare actionTaken bool local FALSE

	/if (${Me.Casting.ID}!=NULL) /return
	/if (${movingTimer}>0 && ${canCastWhileMoving}==FALSE) /return
	/if (${Me.Invis}==TRUE) /return
	/if (${Nav.Active}==TRUE) /return

	/for i ${Math.Calc[${adhocCastList.Count}-1]} downto 0
		/varset targetID ${adhocCastList.Item[${i}].Token[2,_]}
		/if (${Spawn[id ${targetID}].ID}==NULL || ${Spawn[id ${targetID}].Dead}==TRUE) {
			/invoke ${adhocCastList.Erase[${i}]}
		}
	/next i

	/if (${adhocCastList.Count}==0) {
		/RETURN FALSE
	}

	/for i 0 to ${Math.Calc[${adhocCastList.Count}-1]}
		/varset castName ${adhocCastList.Item[${i}].Token[1,_]}
		/varset targetID ${adhocCastList.Item[${i}].Token[2,_]}
		/varset trackRecast ${adhocCastList.Item[${i}].Token[3,_]}

		/if (${isCastReady[${castName}]}==FALSE) /continue
		/invoke (${cq.Append[CAST;SPELL=${castName};TARGETID=${targetID};ONRESULT=onAdhocCastResult;ADHOCINDEX=${i};CANCELCONDITIONS=TARGETDEAD;TRACKRECAST=${trackRecast}]})
		/varset adHocCastPendingTimer 5s
		/varset actionTaken TRUE
		/break
	/next i

	/RETURN ${actionTaken}
}

SUB onAdhocCastResult(string result, string opts) {
	/declare removeIndex string local ${getStackCommandOpt[${opts},ADHOCINDEX]}
	
	/if (${result.NotEqual[FAIL_INTERRUPT]} && ${result.NotEqual[FAIL_FIZZLE]}) {
		/invoke ${adhocCastList.Erase[${removeIndex}]}
	}

	/varset adHocCastPendingTimer 0	
	/RETURN
}
SUB p3_charm_init() {
	/declare charmCheckTimer timer outer 0
	/declare charmCheckTimerInterval int outer 10
	/declare charmCallAttackTimer timer outer 0
	/declare charmCallAttackTimerInterval outer 30

	/declare charmSpawnID int outer 0
	/declare charmUseSpell string outer NONE
	/declare charmRequireDebuffsImport string outer NONE
	/declare charmRequireDebuffs list outer
	/declare charmOnBreakCommand string outer NONE

	/varset charmUseSpell 				${getBotIniOption[Charm.UseSpell,${charmUseSpell}]}
	/varset charmRequireDebuffsImport	${getBotIniOption[Charm.RequireDebuffs,${charmRequireDebuffsImport}]}
	/varset charmOnBreakCommand 		${getBotIniOption[Charm.OnBreakCommand,${charmOnBreakCommand}]}

	/if (${Bool[${charmRequireDebuffsImport}]}!=FALSE) {
		/invoke ${charmRequireDebuffs.Append[${charmRequireDebuffsImport}]}
	}

	/RETURN
}


SUB charmMaintenance() {

	/if (${charmSpawnID}!=0) /call checkCharmStatus

	/if (${charmSpawnID}!=0 && ${assistSpawnID}!=0 && ${charmCallAttackTimer}==0) {
		/if (${Target.ID} != ${assistSpawnID}) {
			/tar id ${assistSpawnID}
			/delay 3
		}

		/pet attack
		/varset charmCallAttackTimer ${charmCallAttackTimerInterval}
	}

	/RETURN
}


SUB checkCharmStatus() {
	/if (${charmCheckTimer}>0) /RETURN
	/varset charmCheckTimer ${charmCheckTimerInterval}

	/echo Checking charm status...

	/if (${Me.Pet.ID}==${charmSpawnID}) /RETURN
	/if (${Me.Moving}==TRUE) /RETURN
	/if (${Me.Invis}==TRUE) /RETURN
	
	/if (${charmSpawnIsGone[]}==TRUE) {
		/varset charmSpawnID 0
		/RETURN
	}

	/if (${Me.Pet.ID}==NULL) {
		/call charmSpawnByID ${charmSpawnID}
		/if (${Macro.Return}==FALSE) /RETURN 
	}


	/RETURN
}


SUB charmSpawnIsGone() {
	/if (${Spawn[id ${charmSpawnID}].ID}==NULL) {
		/varset charmSpawnID 0
		/RETURN TRUE
	}

	/if (${Spawn[id ${charmSpawnID}].Dead}==TRUE) {
		/varset charmSpawnID 0
		/RETURN TRUE
	}

	/RETURN FALSE
}

SUB charmSpawnByID() {
	/declare i int local 0
	/declare debuffName string local

	/tar id ${charmSpawnID}
	/delay 10

	/if (${charmRequireDebuffs.Count}>0) {
		/for i 0 to ${Math.Calc[${charmRequireDebuffs.Count}-1]}
			/varset debuffName ${charmRequireDebuffs.Item[${i}]}

			/if (${Bool[${Target.Buff[${debuffName}]}]}==FALSE) {
				/bc Charm target requires ${debuffName}, casting...
				/invoke ${cq.Append[CAST;SPELL=${debuffName};TARGETID=${charmSpawnID};]}				
			}
		/next i

	}

	/invoke ${cq.Append[CAST;SPELL=${charmUseSpell};TARGETID=${charmSpawnID};]}

	/RETURN
}

SUB p3_eqemu_init {
	/declare myCorpseName string outer ${Me.CleanName}'s corpse
	/declare currentCorpseTargetID int outer 0

	/RETURN
}

SUB eqemuMaintenance() {
	/if (${Spawn[pccorpse ${myCorpseName} radius 50].ID}!=NULL) {
		/if (${Window[LootWnd]}==TRUE) {
			|/delay 10
			|/notify LootWnd LW_LootAllButton leftmouseup
			/RETURN RESET
		}

		/echo Corpse pickup routine activated...
		/varset currentCorpseTargetID ${Spawn[pccorpse ${myCorpseName} radius 50].ID}

		/while (${Spawn[id ${currentCorpseTargetID}].Distance}>10) {
			/if (${Stick.Active}==FALSE) {
				/stick 5 id ${currentCorpseTargetID}
				/face fast id ${currentCorpseTargetID}
			}
			/delay 3
		}

		/stick off

		/delay 3

		/tar id ${currentCorpseTargetID}
		/delay 2
		/loot
		/delay 5
 		/notify LootWnd LW_LootAllButton leftmouseup

		/RETURN RESET
	}

	/RETURN
}

#event followMe "<#1#> e3 follow me"
#event followMe "<#1#> e3 follow me #2#"

#event followMe "<#1#> p3 follow me"
#event followMe "<#1#> p3 follow me #2#"

#event followMe "[#1#(msg)] p3 follow me"
#event followMe "[#1#(msg)] p3 follow me #2#"

SUB EVENT_followMe(string line, string chatSender, string opts) {
	/if (${Defined[opts]}==FALSE) /declare opts string local ${defaultStickOpts}

	/if (${Spawn[pc =${chatSender}].ID}==${Me.ID}) /return

	/invoke ${cq.Append[FOLLOW;AUTHOR=${chatSender};SPAWNID=${Spawn[pc =${chatSender}].ID};STICKOPTS=${opts}]}
	/varset hardLoopReset TRUE
	/RETURN
}

#event idle "<#*#> p3 idle #1#"
SUB EVENT_idle(string line, string newMode) {
	/if (${newMode.Upper.Equal[ON]}) {
		/bc Idle on.
   		/notify AdvancedDisplayOptionsWindow ADOW_MaxBGFPSSlider newvalue ${Math.Calc[3-9]}
	} else {
		/bc Idle off.
   		/notify AdvancedDisplayOptionsWindow ADOW_MaxBGFPSSlider newvalue ${Math.Calc[25-9]}
	}
	/RETURN
}

#event stop "<#1#> e3 stop"
#event stop "<#1#> p3 stop"
SUB EVENT_stop(string line, string chatSender) {
	/invoke ${cq.Append[STOP;AUTHOR=${chatSender};ASSISTHOLDTIMER=50]}
	/RETURN
}

#event kill "[#1#(msg)] p3 kill #2#"
#event kill "<#1#> p3 kill #2#"
#event kill "[#1#(msg)] assist on #2#"
#event kill "<#1#> assist on #2#"
#event kill "[#1#(msg)] p3 assist on #2#"
#event kill "<#1#> p3 assist on #2#"

SUB event_kill(string line, string chatSender, string spawnID) {
	/if (${assistLock}==TRUE) /RETURN
	/invoke ${cq.Append[KILL;AUTHOR=${chatSender};SPAWNID=${spawnID}]}
	/RETURN
}

#event killLock "[#1#(msg)] p3 killlock #2#"
#event killLock "<#1#> p3 killlock #2#"
#event killLock "[#1#(msg)] assistlock on #2#"
#event killLock "<#1#> assistlock on #2#"

SUB event_killLock(string line, string chatSender, string spawnID) {
	/echo ${spawnID}
	/invoke ${cq.Append[KILL;AUTHOR=${chatSender};SPAWNID=${spawnID};LOCK=YES;]}
	/RETURN
}


#Event buffRequest "#*# tells you, '#2# #1#'" 
#Event buffRequest "#1# tells you, '#2#'" 
SUB EVENT_buffRequest(string line, string who, string msg)
	/declare i int local 0
	/declare requestKeyword ${msg.Upper.Replace[ ,]}
	/declare spawnID int local
	/declare spellName string local
	/declare queueEntry string local
	/declare repeatBuff int local 0

	/if (${brSameGuildOnly}==TRUE && ${Me.Guild.Length}==0) /RETURN
	/if (${brSameGuildOnly}==TRUE && ${Spawn[=${who}].Guild.Length}==0) /RETURN
	/if (${brSameGuildOnly}==TRUE && ${Spawn[=${who}].Guild.NotEqual[${Me.Guild}]}) /RETURN

	/if (${msg.Right[1].Equal[!]}) {
		/varset repeatBuff 1
		/varset requestKeyword ${requestKeyword.Left[-1]}
	}

	/for i 1 to ${iniBuffRequests.Size}
		/if (${iniBuffRequests[${i},1].Equal[-]}) /break

		/if (${Select[${requestKeyword},${iniBuffRequests[${i},${bKeyword}]}]}!=0) {
			/varset spawnID ${Spawn[pc ${who}].ID}
			/varset spellName ${iniBuffRequests[${i},1]}
			/varset queueEntry ${spawnID}_${spellName}_${i}_${repeatBuff}

			/if (${iniBuffRequests[${i},${bRequireTargetClass}].NotEqual[-]}) {
				/if (${Select[${Spawn[id ${spawnID}].Class.ShortName},${iniBuffRequests[${i},${bRequireTargetClass}]}]}==0) /continue
			}

			/if (${repeatBuff}==1) {
				/if (${repeatBuffsQueue.Index[${spawnID}_${i}]}>-1) {
					/tell ${who} You're already in my list for repeat buffs for ${spellName}.
					/continue
				} else {
					/invoke ${repeatBuffsQueue.Append[${spawnID}_${i}]}
					/em beams a smile at ${who}.
				}
			} else {
				/if (${buffQueue.Contains[${queueEntry}]}==TRUE) {
					/tell ${who} You're already queued to receive ${spellName}.
					/continue
				} else {
					/invoke ${buffQueue.Append[${queueEntry}]}
					/em nods at ${who}.
				}
			}

		}

	/next i
/RETURN

#Event pleaseBuffs "#*#says, '#1# needs buffs'" 
#Event pleaseBuffs "#*#says, '#1# needs buffs.'" 
#Event pleaseBuffs "#1# needs buffs." 
SUB EVENT_pleaseBuffs(string line, string emoter, string hailee)
	/if (${brEnabled}==FALSE) /return
	/if (${needsBuffPlayerQueue.Index[${emoter}]}>-1) /return
	/invoke ${needsBuffPlayerQueue.Append[${emoter}]}
	/em looks ${emoter} up and down.
	/delay 2
/RETURN


#Event hailResponse "#1# says, 'Hail, #2#'" 
SUB EVENT_hailResponse(string line, string hailer, string hailee)
	/if (${brEnabled}==FALSE) /return
	/if (${hailee.NotEqual[${Me.CleanName}]}) /return

	/declare response string local 
	/declare i int local 0
	/declare spewedSpells string local
	/declare cleanKeywords string local

	/varset response Send me a tell with one of the following requests:

	/for i 1 to ${iniBuffRequests.Size}
		/if (${spewedSpells.Find[${iniBuffRequests[${i},1]},]}!=NULL) /continue
		/if (${iniBuffRequests[${i},1].Equal[-]}) /break

		/varset cleanKeywords ${iniBuffRequests[${i},${bKeyword}].Upper.Replace[EMOTABLE,]}
		/if (${cleanKeywords.Find[!HIDE]}!=NULL) /continue
		/if (${cleanKeywords.Right[1].Equal[,]}) /varset cleanKeywords ${cleanKeywords.Left[-1]}

		/varset response ${response} ... [ ${cleanKeywords} => ${iniBuffRequests[${i},1]} ]
		/varset spewedSpells ${iniBuffRequests[${i},1]},${spewedSpells}
	/next i

	/if (${brReplyViaTell}==TRUE) {
		/docommand /tell ${hailer} ${response} (${Me.PctMana}m).
	} else {
		/say Hail, ${hailer}. ${response} (${Me.PctMana}m).
	}
	
/RETURN


#EVENT clearBuffRequests "#*#p3 cbr#*#"
SUB event_clearBuffRequests(line, ChatSender)
	/bc Clearing all single, repeat, and emoted buff requests.
	/invoke ${repeatBuffsQueue.Clear}
	/invoke ${buffQueue.Clear}
	/invoke ${needsBuffPlayerQueue.Clear}
/RETURN


#event setAMTags "[#*#(msg)] e3 past #1#"
#event setAMTags "<#*#> e3 past #1#"
#event setAMTags "[#*#(msg)] p3 past #1#"
#event setAMTags "<#*#> p3 past #1#"
SUB EVENT_setAMTags(string line, string newTags)
	/if (${newTags.Upper.Equal[NONE]} || ${newTags.Upper.Equal[CLEAR]}) {
		/invoke ${assistTags.Clear}
		/bc Not using any assist spell tags now.
	} else {
		/invoke ${assistTags.Clear}
		/invoke ${assistTags.Append[${newTags}]}
		/bc Assist tags are now: ${newTags}
	}

	/invoke ${cq.Append[TAGSCHANGED;]}
/RETURN

#event addPASTTags "[#*#(msg)] p3 pastadd #1# #2#"
#event addPASTTags "<#*#> p3 pastadd #1# #2#"
#event addPASTTags "[#*#(msg)] p3 pastadd #1#"
#event addPASTTags "<#*#> p3 pastadd #1#"
SUB EVENT_addPASTTags(string line, string newTags, string dur)

	/declare i int local
	/declare tok string local

	/for i 1 to ${Math.Calc[${newTags.Count[,]}+1]}
		/varset tok ${newTags.Token[${i},,]}
		/if (${assistTags.Contains[${tok.Lower}]}==FALSE) {
			/invoke ${assistTags.Append[${tok}]}
			/bc Adding ${tok} to assist tags.
			/if (${Defined[dur]}==TRUE) {
				/call lockout past_${tok} ${dur}
				/echo adding lockout for ${tok} => ${dur}
			}
		}
	/next i

	/invoke ${cq.Append[TAGSCHANGED;]}
	/doevents flush addPASTTags
/RETURN


#event remPASTTags "[#*#(msg)] e3 pastrem #1#"
#event remPASTTags "<#*#> e3 pastrem #1#"
#event remPASTTags "[#*#(msg)] p3 pastrem #1#"
#event remPASTTags "<#*#> p3 pastrem #1#"
SUB EVENT_remPASTTags(string line, string remTags)
	/call removePastTags "${remTags}"
/RETURN



#event setTwist "[#1#(msg)] p3 twist #2#"
#event setTwist "<#1#> p3 twist #2#"

SUB event_setTwist(string line, string chatSender, string newOrder) {
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return

	/if (${newOrder.Upper.Equal[OFF]}) {
		/twist off 
		/timed 5 /twist off
		/varset doTwist FALSE
		/bc Twist is now off.
		/return
	} else {
		/varset doTwist TRUE
		/bc Twist is now on.
	}

	/invoke ${cq.Append[NEWTWIST;ORDER=${newOrder}]}

	/RETURN
}


#event perf "[#1#(msg)] p3 perf"
#event perf "<#1#> p3 perf"

SUB event_perf(string line, string chatSender, string newOrder) {
	/declare i int local

	/for i 0 to ${Math.Calc[ ${modules.Count}-1 ]}
		/echo ${modules.Item[${i}]} ::: ${Math.Calc[(${p3_${modules.Item[${i}]}_perftime}+1) / (${MacroQuest.Running} - ${perfStart}) * 100 ]}%
	/next i

	/echo idle:: ${Math.Calc[(${perfIdle}+1) / (${MacroQuest.Running} - ${perfStart}) * 100 ]}%

	/RETURN
}



#event toggleSlay "[#*#(msg)] e3 slay #1#"
#event toggleSlay "<#*#> e3 slay #1#"
#event toggleSlay "[#*#(msg)] p3 slay #1#"
#event toggleSlay "<#*#> p3 slay #1#"
SUB EVENT_toggleSlay(string line, string newMode) {
	/if (${amSlayLeader}==FALSE) /RETURN

	/if (${newMode.Upper.Equal[ON]}) {
		/varset slayEnabled TRUE
		/bc Slay Mode is now ON.
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset slayEnabled FALSE
		/bc Slay Mode is now OFF.
	}
	/RETURN
}

#event buildSlayTeam "[#*#(msg)] e3 build slay team"
#event buildSlayTeam "<#*#> e3 build slay team"
#event buildSlayTeam "[#*#(msg)] p3 build slay team"
#event buildSlayTeam "<#*#> p3 build slay team"
SUB EVENT_buildSlayTeam(string line, string newMode) {
	/if (${amSlayLeader}==FALSE) /RETURN

	/call slayBuildTeam

	/RETURN
}


#EVENT campCommand "[#1#(msg)] p3 camp #2#"
#EVENT campCommand "<#1#> p3 camp #2#"
#EVENT campCommand "[#1#(msg)] e3 camp #2#"
#EVENT campCommand "<#1#> e3 camp #2#"
SUB EVENT_campCommand(string line, string source, string newMode)
	/if (${Spawn[=${source}].ID}==NULL) {
		/bc Ignoring because ${source} is not in my zone.
		/return
	}

	/if (${newMode.Upper.Equal[OFF]}) {
		/invoke ${cq.Append[CAMPOFF;SOURCENAME=${source}]}
		/return
	}

	/if (${newMode.Upper.Equal[HERE]}) {
		/invoke ${cq.Append[CAMPON;TYPE=LOC;SOURCENAME=${source};LOCX=${Spawn[${source}].X};LOCY=${Spawn[${source}].Y};LOCZ=${Spawn[${source}].Z}]}
		/return
	}

	/if (${newMode.Upper.Equal[THERE]}) {
		/invoke ${cq.Append[CAMPON;TYPE=SPAWN;SPAWNTARGETID=${Me.ID}]}
		/return
	}


	| IF "NEWMODE" WAS NOT HERE OR THERE, THEN ASSUME IT WAS A SPAWN
	/if (${Spawn[=${newMode}].ID}!=NULL) {
		/invoke ${cq.Append[CAMPON;TYPE=SPAWN;SPAWNTARGETID=${Spawn[=${newMode}].ID}]}
		/return
	}

/RETURN


#event retreatHere "[#1#(msg)] p3 retreat #2#"
#event retreatHere "<#1#> p3 retreat #2#"
SUB event_retreatHere(string line, string who, string newMode)
	/if (${newMode.Upper.Equal[HERE]}) {
		/invoke ${cq.Append[RETREATON;LOCXYZ=${Spawn[pc ${who}].X} ${Spawn[pc ${who}].Y} ${Spawn[pc ${who}].Z}]}
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/invoke ${cq.Append[RETREATOFF;]}
	}
/RETURN


#event anchorHere "[#1#(msg)] p3 anchor #2#"
#event anchorHere "<#1#> p3 anchor #2#"
SUB event_anchorHere(string line, string who, string newMode)
	/if (${newMode.Upper.Equal[HERE]}) {
		/invoke ${cq.Append[DROPANCHOR;LOCXYZ=${Spawn[pc ${who}].X} ${Spawn[pc ${who}].Y} ${Spawn[pc ${who}].Z}]}
		/bc Achor point set at ${who}'s location. 
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/invoke ${cq.Append[RAISEANCHOR;]}
		/bc Achor raised.
	}
/RETURN

#event adistChange "#*#tells the raid, 'p3 adist #1#'"
#event adistChange "[#*#(msg)] p3 adist #1#"
#event adistChange "<#*#> p3 adist #1#"
#event adistChange "[#*#(msg)] e3 adist #1#"
#event adistChange "<#*#> e3 adist #1#"
SUB EVENT_adistChange(string line, string newDist)
	/varset meleeStickDistance ${newDist}
	/call setActiveStickParams ${stickMode}

	/varset needRestick TRUE
	/bc Melee stick distance is now ${newDist}
/RETURN



#EVENT adhocCast "[#1#(msg)] e3 cast #2#@#3#"
#EVENT adhocCast "<#1#> e3 cast #2#@#3#"
#EVENT adhocCast "[#1#(msg)] p3 cast #2#@#3#"
#EVENT adhocCast "<#1#> p3 cast #2#@#3#"
SUB EVENT_adhocCast(string line, string chatSender, string castName, string castTarget)
	/call addCastOrder "${castName.Upper}" "${castTarget}" FALSE
/RETURN


#EVENT roamWith "[#1#(msg)] e3 roam with #1#"
#EVENT roamWith "<#*#> e3 roam with #1#"
#EVENT roamWith "[#1#(msg)] p3 roam with #1#"
#EVENT roamWith "<#*#> p3 roam with #1#"
SUB EVENT_roamWith(string line, string spawnSearch)
	/if (${Spawn[=${spawnSearch}].ID}==NULL) {
		/bc Ignoring because ${spawnSearch} is not in my zone.
		/RETURN
	}

	/varset roamTargetID ${Spawn[${spawnSearch}].ID}
	/invoke ${cq.Append[ROAMLOCK;TARGETID=${roamTargetID};]}
/RETURN

#EVENT stopRoam "[#1#(msg)] e3 roam off"
#EVENT stopRoam "<#1#> e3 roam off"
#EVENT stopRoam "[#1#(msg)] p3 roam off"
#EVENT stopRoam "<#1#> p3 roam off"
SUB EVENT_stopRoam(string line, string source) {
	/invoke ${cq.Append[ROAMOFF;SOURCENAME=${source};]}
	/RETURN
}



#event autoMed "[#1#(msg)] p3 automed #2#"
#event autoMed "<#1#> p3 automed #2#"
SUB event_autoMed(string line, string who, string newMode)
	/if (${ignoreAutoMed}==TRUE) /return

	/if (${newMode.Upper.Equal[ON]}) {
		/call setAutoMed TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/call setAutoMed FALSE
	}
/RETURN


#EVENT medOffFromHit "#*# YOU for#*#points of dam#*#"
SUB EVENT_medOffFromHit
	/if (${doAutoMed}==TRUE) {
		/call pauseAutoMed 20s
	}
/RETURN

#event expSpammerResponder "#*#You gained raid experience#*#"
#event expSpammerResponder "#*#You gain party experience#*#"
#event expSpammerResponder "#*#You gain experience#*#"
SUB event_expSpammerResponder
	/call expTrackerNewExp
/return




#event buffsEnabled "[#1#(msg)] p3 buffs #2#"
#event buffsEnabled "<#1#> p3 buffs #2#"
SUB event_buffsEnabled(string line, string who, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset buffsEnabled TRUE
		/bc Buffs are now ON.
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset buffsEnabled FALSE
		/bc Buffs are now OFF.
	}
/RETURN


#event tauntSuccess "You capture #*# attention!"
#event tauntSuccess "You capture #*# with your unparalleled reproach!"
SUB EVENT_tauntSuccess(string line, string newMode)
	/if (${Target.ID}==NULL) /return
	
	/invoke ${tauntSuccessList.Append[${Target.ID}_${MacroQuest.Running}]}
/RETURN


#EVENT autoRezToggle "#*#p3 autorez #1#"
SUB event_autoRezToggle(string line, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset autoRezEnabled TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset autoRezEnabled FALSE
	} else {
		/bc Unknown AutoRez mode. Use ON or OFF.
		/return
	}

	/bc AutoRezEnabled is now: ${newMode}.

/RETURN



#EVENT toggleHeals "#*#p3 heals #1#"
SUB event_toggleHeals(string line, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset healsEnabled TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset healsEnabled FALSE
	} else {
		/bc Unknown Heals mode. Use ON or OFF.
		/return
	}

	/bc HealsEnabled is now: ${newMode}.

/RETURN


#EVENT toggleAutoMez "#*#p3 automez #1#"
SUB event_toggleAutoMez(string line, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset autoMezEnabled TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset autoMezEnabled FALSE
	} else {
		/bc Unknown autoMezEnabled mode. Use ON or OFF.
		/return
	}

	/bc AutoMezEnabled is now: ${newMode}.
	/em shrugs.

/RETURN




#EVENT toggleAutoAssist "#*#p3 autoassist #1#"
#EVENT toggleAutoAssist "#*#p3 autoass #1#"
#EVENT toggleAutoAssist "#*#p3 aa #1#"
SUB event_toggleAutoAssist(string line, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset autoAssist TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset autoAssist FALSE
	} else {
		/bc Unknown autoAssist mode. Use ON or OFF.
		/return
	}

	/bc AutoAssist is now: ${newMode}.
	/em shrugs.
/RETURN



#EVENT mezBroke "#1# has been awakened by#*#"
SUB EVENT_mezBroke(string line, string mobName)
	/declare i int local
	/declare mob spawn local

	/declare mobCount int local ${SpawnCount[=${mobName}]}

	| FIND THE CORRECT MOB. INITIATE A RE-MEZ BY REMOVING FROM MEZLIST AND LET MEZ CHECK FIND IT AGAIN
	/for i 1 to ${mobCount}
		/vardata mob NearestSpawn[${i},=${mobName}]
		/if (${autoMezList.Index[${mob.ID}]}!=-1) {
			/tar id ${mob.ID}
			/delay 10
			/if (${Target.Mezzed.ID}==NULL) {
				/invoke ${autoMezList.Erase[${autoMezList.Index[${mob.ID}]}]}
				/call wipeLockout mez_${mob.ID}
				/return
			}
		}
	/next i
/RETURN



#event charmOn "[#*#(msg)] p3 charm #1#"
SUB event_charmOn(string line, int spawnID)
	/if (${Bool[${charmUseSpell}]}==FALSE) {
		/bc I am not configured to accept charm commands.
		/RETURN
	}

	/varset charmSpawnID ${spawnID}
	/bc I will attempt to keep spawnID ${spawnID} ( ${Spawn[id ${charmSpawnID}]} ) charmed.
/RETURN

#event charmOff "[#*#(msg)] p3 charm off"
#event charmOff "<#*#> p3 charm off"
SUB event_charmOff(string line)
	/if (${Bool[${charmUseSpell}]}==FALSE) /return
	/if (${charmSpawnID}==0) /return

	/bc I will no longer try to charm spawnID ${charmSpawnID}.

	/varset charmSpawnID 0
/RETURN

#event useMelee "[#*#(msg)] p3 melee #1#"
#event useMelee "<#*#> p3 melee #1#"
SUB event_useMelee(string line, string newMode)
	/if (${newMode.Upper.Equal[ON]}) {
		/varset useMeleeCombat TRUE
	} else /if (${newMode.Upper.Equal[OFF]}) {
		/varset useMeleeCombat FALSE
	} else {
		/bc Unknown useMeleeCombat mode. Use ON or OFF.
		/return
	}

	/bc useMeleeCombat is now: ${newMode}.
/RETURN


#event castFizzle "#*#Your spell fizz#*#!"
SUB event_castFizzle(string line)
	/varset castResult FIZZLE
/RETURN

#event castPower "#*#Your spell is too power#*#"
SUB event_castPower(string line)
	/varset castResult NOHOLD
/RETURN


#event castNoFunction "#*#have entered an area where levitation effects do not function#*#"
SUB event_castNoFunction(string line)
	/varset castResult NOHOLD
/RETURN

#event castResist "#*# resisted your #*#!"
#event castResist "#*# resisted the #*# spell."
SUB event_castResist(string line)
	/varset castResult RESIST
/RETURN

#event castImmune "Your target is immune to #*#"
SUB event_castImmune(string line)
	/varset castResult IMMUNE
/RETURN

#event castNoTakeHold "Your #*# did not take hold#*#"
#event castNoTakeHold "Your spell did not take hold#*#"
SUB event_castNoTakeHold(string line)
	/varset castResult NOHOLD
/RETURN


#event castInterrupted "Your #*# spell is interrupted."
#event castInterrupted "Your spell is interrupted."
SUB event_castInterrupted(string line)
	/varset castResult INTERRUPT
/RETURN


#event spewItem "[#*#(msg)] e3 item #1#"
#EVENT spewItem "<#*#> e3 item #1#"
#event spewItem "[#*#(msg)] p3 item #1#"
#EVENT spewItem "<#*#> p3 item #1#"
   SUB EVENT_spewItem(string line, string slotNumber)
      /if (${slotNumber.Upper.Equal[charm]}) /varset slotNumber 0
      /if (${slotNumber.Upper.Equal[leftear]}) /varset slotNumber 1
      /if (${slotNumber.Upper.Equal[head]}) /varset slotNumber 2
      /if (${slotNumber.Upper.Equal[face]}) /varset slotNumber 3
      /if (${slotNumber.Upper.Equal[rightear]}) /varset slotNumber 4
      /if (${slotNumber.Upper.Equal[neck]}) /varset slotNumber 5
      /if (${slotNumber.Upper.Equal[shoulder]}) /varset slotNumber 6
      /if (${slotNumber.Upper.Equal[shoulders]}) /varset slotNumber 6
      /if (${slotNumber.Upper.Equal[arms]}) /varset slotNumber 7
      /if (${slotNumber.Upper.Equal[back]}) /varset slotNumber 8
      /if (${slotNumber.Upper.Equal[leftwrist]}) /varset slotNumber 9
      /if (${slotNumber.Upper.Equal[rightwrist]}) /varset slotNumber 10
      /if (${slotNumber.Upper.Equal[ranged]}) /varset slotNumber 11
      /if (${slotNumber.Upper.Equal[hands]}) /varset slotNumber 12
      /if (${slotNumber.Upper.Equal[mainhand]}) /varset slotNumber 13
      /if (${slotNumber.Upper.Equal[offhand]}) /varset slotNumber 14
      /if (${slotNumber.Upper.Equal[leftfinger]}) /varset slotNumber 15
      /if (${slotNumber.Upper.Equal[rightfinger]}) /varset slotNumber 16
      /if (${slotNumber.Upper.Equal[chest]}) /varset slotNumber 17
      /if (${slotNumber.Upper.Equal[legs]}) /varset slotNumber 18
      /if (${slotNumber.Upper.Equal[feet]}) /varset slotNumber 19
      /if (${slotNumber.Upper.Equal[waist]}) /varset slotNumber 20
      /if (${slotNumber.Upper.Equal[powersource]}) /varset slotNumber 21
      /if (${slotNumber.Upper.Equal[ammo]}) /varset slotNumber 22

      |/bc ${Me.Inventory[${slotNumber}].HP} HP / ${Me.Inventory[${slotNumber}].Mana} MP / ${Me.Inventory[${slotNumber}].AC} AC (${Me.Inventory[${slotNumber}].ItemLink[CLICKABLE]})
      /say ${Me.Inventory[${slotNumber}].HP} HP / ${Me.Inventory[${slotNumber}].Mana} MP / ${Me.Inventory[${slotNumber}].AC} AC (${Me.Inventory[${slotNumber}].ItemLink[CLICKABLE]})
   /RETURN

#event p3find "[#*#(msg)] p3 find #1#"
#event p3find "<#*#> p3 find #1#"
SUB EVENT_p3find(string line, string itemName) {
	/if (${FindItem[${itemName}].ID}!=NULL) {
		/say Found in my inventory: ${FindItem[${itemName}].ItemLink[CLICKABLE]}
	}

	/if (${FindItemBank[${itemName}].ID}!=NULL) {
		/say Found in my bank: ${FindItemBank[${itemName}].ItemLink[CLICKABLE]}
	}

	/RETURN
}

#event mydeath "#*#You have been slain#*#"
SUB EVENT_mydeath(string line)
	/if (${beepOnDeath}==TRUE) {
		/if (${beepOnDeathSound.Equal[FALSE]}) {
			/beep
		} else {
			/beep sounds/${beepOnDeathSound}
		}
	}
/RETURN
SUB p3_exptrack_init() {
	
	/declare doExpReport bool outer TRUE
	/varset doExpReport ${getBotIniOption[Misc.ExperienceReports,${doExpReport}]}

	/declare curRegPct float outer ${Math.Calc[${Me.Exp}/1000].Precision[3]}
	/declare curAAPct float outer ${Math.Calc[${Me.AAExp}/1000].Precision[3]}


	/RETURN
}


SUB exptrackMaintenance() {
	/RETURN
}


SUB expTrackerNewExp() {
	/declare newRegPct float local ${Math.Calc[${Me.Exp}/1000].Precision[3]}
	/declare newAAPct float local ${Math.Calc[${Me.AAExp}/1000].Precision[3]}

	/declare gain float local

	/if (${doExpReport}==TRUE) {

		/if (${newRegPct}<${curRegPct}) {
			/varset gain ${Math.Calc[(${newRegPct.Precision[3]})- (100-${curRegPct.Precision[3]})]}
		} else /if (${newRegPct}>${curRegPct}) {
			/varset gain ${Math.Calc[${newRegPct.Precision[3]} - ${curRegPct.Precision[3]} ]}
		}

		/if (${gain}>0) {
			/bc Regular Exp Gain: ${gain.Precision[3]}% (${Math.Calc[${Me.Exp}/1000].Precision[3]}% through ${Me.Level})
		}

		/varset gain 0

		/if (${newAAPct}<${curAAPct}) {
			/varset gain ${Math.Calc[(100-${curAAPct.Precision[3]}) + (${newAAPct.Precision[3]})]}
		} else /if (${newAAPct}>${curAAPct}) {
			/varset gain ${Math.Calc[${newAAPct.Precision[3]} - ${curAAPct.Precision[3]} ]}
		}

		/if (${gain}>0) {
			/bc AA Exp Gain: ${gain.Precision[3]}%  (${Me.AAPoints} banked)
		}

		/varset curRegPct ${newRegPct.Precision[3]}
		/varset curAAPct ${newAAPct.Precision[3]}
	}
	/RETURN
}


SUB p3_global_init {
	/declare autoKeywordIgnoreValues ON,OFF,YES,NO,NONE
	/declare iniSectionsAutoProcess string outer Heals,CombatSpells,Buffs,AutoAbilities,BuffRequests,TankActions,AutoDebuffs
	/declare iniSectionsAutoValidate string outer Heals,CombatSpells,Buffs,AutoAbilities,BuffRequests,TankActions,AutoDebuffs
	/declare debugMode bool outer FALSE
	/declare botIniFile string outer -
	/declare allNetbotNames string outer
	/declare beepOnDeath bool outer TRUE
	/declare beepOnDeathSound string outer spx_dth.wav

	/declare maxForegroundFPS int outer 30
	/declare maxBackgroundFPS int outer 20

	/call processCommandLine
	/call initializeEntryFlagSystem
	/call loadIniSections
	/call processAutoValidateIniSections
	/call gatherNetbotNames

	/declare bcsChannels string outer ${getDefaultBCSChannels[]}
	/varset bcsChannels ${getBotIniOption[Misc.EQBCSChannels,${bcsChannels}]}

	/varset beepOnDeath ${getBotIniOption[Misc.BeepOnDeath,TRUE,general]}
	/varset beepOnDeathSound ${getBotIniOption[Misc.BeepOnDeathSound,${beepOnDeathSound},general]}

	/ECHO bccmd channels ${bcsChannels}
	/bccmd channels ${bcsChannels}

	/notify AdvancedDisplayOptionsWindow ADOW_MaxBGFPSSlider newvalue ${Math.Calc[${maxBackgroundFPS}-9]}
	/notify AdvancedDisplayOptionsWindow ADOW_MaxFPSSlider newvalue ${Math.Calc[${maxForegroundFPS}-9]}
	/notify OptionsDisplayPage ODP_LODBiasSlider newvalue 0
	/notify AdvancedDisplayOptionsWindow ADOW_ActorClipPlaneSlider newvalue 50
	/notify OptionsWindow ODP_ClipPlaneSlider newvalue 6



	/RETURN
}

SUB globalMaintenance() {
	/if (${checkOpenWindows[]}==TRUE) {
		/delay 10
		/RETURN RESET
	}

	/if (${Me.Dead}==TRUE || ${Me.State.Equal[HOVER]}) {
		/delay 10
		/RETURN RESET
	}

	/RETURN
}

SUB loadIniSections {
	/declare sections string local ${Ini[${botIniFile}]}
	/declare a string local
	/declare i int local 1
	/declare sectionName string local
	/declare shortSectionName string local
	/declare newArrayName string local

	/for i 1 to ${sections.Count[|]}
		/varset sectionName ${sections.Token[${i},|]}

		/if (${sectionName.Length}==0 || ${Bool[${sectionName}]}==NULL) /continue
		/if (${Select[${sectionName},${iniSectionsAutoProcess}]}==0) /continue

		/varset shortSectionName ${sectionName.Replace[ ,]}
		/varset newArrayName ini${shortSectionName} 

		/declare ${newArrayName}[96,96] string outer -
		/declare tmpArray[96] string outer
		/call getIniSectionToArray "${botIniFile},${shortSectionName}" tmpArray
		/call processArray tmpArray ${newArrayName}
		/deletevar tmpArray
	/next i

	/for i 1 to ${Math.Calc[${iniSectionsAutoProcess.Count[,]}+1]}
		/if (${Defined[ini${iniSectionsAutoProcess.Token[${i},,]}]}==FALSE) {
			/declare ini${iniSectionsAutoProcess.Token[${i},,]}[1,1] string outer -
		}
	/next i

	/RETURN
}

SUB processAutoValidateIniSections() {
	/declare i int local
		
	/for i 1 to ${Math.Calc[${iniSectionsAutoValidate.Count[,]}+1]}
		/echo Validating: ini${iniSectionsAutoValidate.Token[${i},,]}
		/call validateSpellBasedArray ini${iniSectionsAutoValidate.Token[${i},,]}
	/next i

	/RETURN
}

SUB initializeEntryFlagSystem {
	/declare flagNamesByIndex list outer
	/invoke ${flagNamesByIndex.Append[bNull,bName,bValue,bTargets,bExcludeTargets,bTargetOverLevel,bCastableDuringAssist,bSelfOverHP,bSelfUnderHP,bSelfOverMana,bSelfUnderMana,bCastableOnlyResting,bCastOnlyDuringAssist,bSelfUnderEnd,bSelfOverEnd,bNoCancelChecks,bRequireGroupInRange,bTargetUnderHP,bTargetOverHP,bNotIfShortBuff,bNotIfLongBuff,bRecastDelay,bHealPct,bTargetRace,bCombatOnly,bTargetUnderLevel,bUseTeamIndex,bRequireMobsInProximity,bForceSpellID,bRequireTargetClass,bNoSitTimer,bRequireBodyType,bRequireDiseased,bRequireGroup,bRequireHurtPartyMembers,bRequireMaxMobsInProximity,bRequireAssistTarget,bRequirePoisoned,bDoCommand,bNotToT,bKeyword,bRebuffSeconds,bActivateBandolier,bRevertToBandolier,bFreeze,bInstructRemove,bMaxResists,bExtendedStackCheck,bIncludeXTargets,bNoCast,bIncludeGroup,bMemInGem,bOnlyXTargets,bRequireCastIdle,bOnlyAfterTaunt,bTargetLifeManaRatio,bAmToT,bRequireCursed,bRequireAssistTag,bNotIfAssistTag,bRequireUW,bCancelAtHP,bAssumeSuccess,bRequireTeamIndexOver,bIgnoreTargetType,bNotIfMounted,bEnabled,bTagsInvalidated,bIncludeNetBotPets,bOnlyNetBotPets,bRequireTeamIndex,bTargetUnderDistance,bMyName,bCheckShortBuffs,bForceTargetType,bRequireBehindAssistTarget,bAutoDebuff,bAutoDebuffOnly,bCastableMoving,bGiftOfMana,bTargetType,bNoTwistStop]}
	
	/declare i int local
	/for i 1 to ${Math.Calc[${flagNamesByIndex.Count}-1]}
		/declare ${flagNamesByIndex.Item[${i}]} string outer ${i}
	/next i

	/return  
}

SUB processArrayTargets(string arrayName, int defaultToNetBots) {
	/declare i int local
	/declare j int local
	/declare finalTargets list local
	/declare removeTargets list local
	/declare finalString string local

	/for i 1 to 64
		/if (${${arrayName}[${i},1].Equal[-]}) /break

		/invoke ${finalTargets.Clear}
		/invoke ${removeTargets.Clear}
		/varset finalString

		/if (${${arrayName}[${i},${bTargets}].NotEqual[-]}) {
			/call processTargets "${${arrayName}[${i},${bTargets}]}"
			/invoke ${finalTargets.Append[${Macro.Return}]}
		} else {
			/invoke ${finalTargets.Append[${allNetbotNames}]}
		}

		/if (${${arrayName}[${i},${bExcludeTargets}].NotEqual[-]}) {
			/call processTargets "${${arrayName}[${i},${bExcludeTargets}]}"
			/invoke ${removeTargets.Append[${Macro.Return}]}

			/for j 0 to ${Math.Calc[${removeTargets.Count}-1]}
				/invoke ${finalTargets.Remove[${removeTargets.Item[${j}]}]}
			/next j
		}

		/for j 0 to ${Math.Calc[${finalTargets.Count}-1]}
			/varset finalString ${finalString},${finalTargets.Item[${j}]}
		/next j
		/varset finalString ${finalString.Right[-1]}

		/varset ${arrayName}[${i},${bTargets}] ${finalString}

	/next i

	/RETURN
}

SUB processTargets(string targets) {
	/declare i int local 
	/declare e string local 
	/declare max int local ${Math.Calc[${targets.Count[,]}+1]}
	/declare ret string local
	/declare ret2 string local

	/for i 1 to ${max}
		/varset e ${targets.Token[${i},,]}
		/if (${e.Left[1].Equal[@]}) {
			/call getMatchesForKey "${e}"

			/if (${Macro.Return.Length}==0) /continue

			/if (${ret.Length}==0) {
				/varset ret ${Macro.Return}
			} else {
				/varset ret ${Macro.Return},${ret}
			}
		} else {
			/if (${ret.Length}==0) {
				/varset ret ${e}
			} else {
				/varset ret ${ret},${e}
			}
		}
	/next i

	/RETURN ${ret}
}

SUB processArray(string sourceArray, string destArray) {
	/declare i int local 1
	/declare e string local

	/declare j int local 1
	/declare sectionText string local 
	/declare sectionValue string local 
	/declare sectionName string local 
	/declare keyName string local
	/declare keyValue string local

	/for i 1 to 64
		/varset e ${${sourceArray}[${i}]}

		/if (${Bool[${e}]}==FALSE) /goto :loopesc

		/varset keyName ${e.Token[1,|]}
		/varset keyValue ${e.Right[-${Math.Calc[${keyName.Length}+1]}]}

		/varset ${destArray}[${i},${bName}] ${keyName}
		/varset ${destArray}[${i},${bValue}] ${keyValue}

		/for j 1 to ${Math.Calc[${keyValue.Count[|]}+1]}
			/varset sectionText ${keyValue.Token[${j},|]}
			/if (${sectionText.Length}==0 || ${Bool[${sectionText}]}==NULL) /goto :loopnexti

			/varset sectionName ${sectionText.Token[1,:]}
			/if (${Select[${sectionName},${autoKeywordIgnoreValues}]}>0) /goto :loopnextj

			/if (${sectionText.Count[:]}>0) {
				/varset sectionValue ${sectionText.Token[2,:]}
			} else {
				/varset sectionValue ${sectionText}
			}
			
			/if (${Defined[b${sectionName}]}==FALSE) {
				/bc Warning: >>> ${sectionName} <<< is not a recognized parameter.
				/continue
			}
			
			/varset ${destArray}[${i},${b${sectionName}}] ${sectionValue}

			:loopnextj
		/next j

		:loopnexti
	/next i
	:loopesc
	/RETURN
}

SUB getIniSectionToArray(string iniKey, string arrayName) {
	/declare iniSectionKeys string local
	/declare keyCount int local
	/declare i int local

	/deletevar ${arrayName}

	/varset iniSectionKeys ${Ini[${iniKey}]}

	| EMPTY SECTION? MAKE AN EMPTY ARRAY AND BAIL
	/if (${iniSectionKeys.Equal[NULL]}) {
		/declare ${arrayName}[0] string outer
		/return
	}

	/varset keyCount ${Math.Calc[${iniSectionKeys.Count[|]}-1]}

	| re-create the array with the appropriate size
	/declare ${arrayName}[${keyCount}] string outer

	| fetch and store the ini sections into the array
	/for i 1 to ${keyCount}
		/varset ${arrayName}[${i}] ${iniSectionKeys.Arg[${i},|].Arg[1,#]}|${Ini[${iniKey},${iniSectionKeys.Arg[${i},|]}]}
	/next i

	/RETURN
}

SUB getMatchesForKey(string allowKey) {
	/declare i int local 
	/declare netbotCount int local ${Math.Calc[${NetBots.Counts}]}
	/declare netbotName string local
	/declare netbotClass string local 
	/declare ret string local

	/for i 1 to ${netbotCount}
		/varset netbotName ${NetBots.Client[${i}]}
		/call characterPassesAllowKey ${netbotName} ${allowKey}
		/if (${Macro.Return}==TRUE) {
			/if (${ret.Length}==0) {
				/varset ret ${netbotName}
			} else {
				/varset ret ${ret},${netbotName}
			}
		}
	/next i

	/return ${ret}
}

SUB characterPassesAllowKey(string charName, string allowKey) {
	/if (${Spawn[pc ${charName}].ID}==NULL) /return FALSE

	/declare searchKey string

	/declare xspawn spawn local
	/vardata xspawn Spawn[pc ${charName}]

	/if (${allowKey.Equal[ALL]}) /return TRUE
	/if (${allowKey.Upper.Equal[@ALLNETBOTS]}) /return TRUE

	/if (${allowKey.Upper.Equal[@SELF]}) {
		/if (${xspawn.ID}==${Me.ID}) /RETURN TRUE
		/RETURN FALSE
	}

	/if (${allowKey.Upper.Equal[@MANAREGENCLASSES]}) {
		/if (${manaRegenClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@HASTECLASSES]}) {
		/if (${hasteClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@MANACLASSES]}) {
		/if (${manaClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@MELEECLASSES]}) {
		/if (${meleeClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@MONKS]}) {
		/if (${xspawn.Class.ShortName.Equal[MNK]}) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@ROGUES]}) {
		/if (${xspawn.Class.ShortName.Equal[ROG]}) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@BERSERKERS]}) {
		/if (${xspawn.Class.ShortName.Equal[BER]}) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@KNIGHTS]}) {
		/if (${knightClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@TANKS]}) {
		/if (${tankClasses.Find[${xspawn.Class.ShortName}]}!=NULL) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@CLERICS]}) {
		/if (${xspawn.Class.ShortName.Equal[CLR]}) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Equal[@BARDS]}) {
		/if (${xspawn.Class.ShortName.Equal[BRD]}) /return TRUE
		/return FALSE
	}

	/if (${allowKey.Upper.Left[5].Equal["ONLY:"]}==TRUE) {
		/varset searchKey ,${allowKey.Arg[2,:]},
		/if (${searchKey.Upper.Find[${charName.Upper}]}!=0) /return TRUE
	}

	/if (${allowKey.Upper.Equal[@GROUP]}==TRUE) {
		/if (${Group.Member[${charName}]}!=NULL) /return true
	}
	
	/RETURN
}

SUB characterPassesAllowKeySeries(string charName, string series) {
	/declare i int local 0
	/declare ikey string local

	/for i 1 to ${Math.Calc[${series.Count[,]}+1]}
		/varset ikey ${series.Token[${i},,]}

		/if (${ikey.Left[1].Equal[@]}) {
			/call characterPassesAllowKey ${charName} ${ikey}
			/if (${Macro.Return}==TRUE) /return TRUE
		} else {
			/if (${charName.Upper.Equal[${ikey.Upper}]}) /return TRUE
		}
	/next i

	/return FALSE
}

SUB gatherNetbotNames {
	/declare i int local 
	/declare netbotCount int local ${Math.Calc[${NetBots.Counts}]}
	/declare netbotName string local
	/declare ret string local

	/for i 1 to ${netbotCount}
		/if (${ret.Length}==0) {
			/varset ret ${NetBots.Client[${i}]}
		} else {
			/varset ret ${ret},${NetBots.Client[${i}]}
		}
	/next i

	/varset allNetbotNames ${ret}

	/RETURN
}

SUB validateTagsFromArray(string arrName) {
	/echo validating tags for ${arrName}

	/declare i int local 

	/for i 1 to 64
		/if (${${arrName}[${i},${bNotIfAssistTag}].Equal[-]} && ${${arrName}[${i},${bRequireAssistTag}].Equal[-]}) /continue

		/if (${${arrName}[${i},${bNotIfAssistTag}].NotEqual[-]}) {
			/if (${assistTags.Count}>0 || ${persistentAssistTags.Count}>0) {
				|/echo bNotIfAssistTag: ${${arrName}[${i},${bNotIfAssistTag}]} TRUE
				/call validateAssistTags ${${arrName}[${i},${bNotIfAssistTag}]} TRUE
				/if (${Macro.Return}==TRUE) {
					|/echo invalidating: ${${arrName}[${i},1]}
					/varset ${arrName}[${i},${bTagsInvalidated}] YES
				} else {
					/varset ${arrName}[${i},${bTagsInvalidated}] -
				}
			}
		}
		/if (${${arrName}[${i},${bRequireAssistTag}].NotEqual[-]}) {
			/if (${assistTags.Count}==0 && ${persistentAssistTags.Count}==0) /continue
			|/ECHO bRequireAssistTag ${${arrName}[${i},${bRequireAssistTag}]}
			/call validateAssistTags ${${arrName}[${i},${bRequireAssistTag}]}
			/if (${Macro.Return}==FALSE) {
				|/echo invalidating: ${${arrName}[${i},1]}
				/varset ${arrName}[${i},${bTagsInvalidated}] YES
			} else {
				/varset ${arrName}[${i},${bTagsInvalidated}] -
			}
		}

	/next i

	/RETURN
}

SUB validateSpellBasedArray(string arrName) {
	/declare i int local 

	/for i 1 to 64
		/if (${${arrName}[${i},1].Equal[-]}) /break

		/if (${isRealSpell[${${arrName}[${i},${bName}]}]}==FALSE) {
			/echo Error: >>>${${arrName}[${i},1]}<<< does not appear to be a valid spell/item/abilty in array [${arrName}]. Check spelling? Non-existant item/clicky? Disabling this spell entry until macro restart.
			/varset ${arrName}[${i},${bEnabled}] NO
		}

	/next i
	/RETURN
}

SUB isRealSpell(string request) {
	/declare castType string local
	/call getCastTypeByCastRequest "${request}"
	/varset castType ${Macro.Return}
	/if (${castType.Equal[UNKNOWN]}) /return FALSE
	/return TRUE
}

SUB memorizeSpellInGem(string spellName, int gemNumber) {
	/if (${Me.Book[${spellName}]}==NULL) {
		/bc Cannot memorize ${spellName} - I don't have this spell.
		/RETURN FALSE
	}

	/if (${Me.Casting.ID}!=NULL) {
		/echo interrupt.
		/interrupt
		/delay 5
	}

	/memspell ${gemNumber} "${spellName}"

	/delay 3

	/while (${Window[SpellBookWnd]}==TRUE) {
		/delay 3
		/if (${Gem[${spellName}]}!=NULL) /break
	}

	/delay 35 ${Me.SpellReady[${spellName}]}

	/RETURN TRUE
}

SUB isNetBotAttackingID(int targetID) {
	/declare netbotCount int local ${NetBots.Counts}
	/declare i int local
	/declare netbotName string local


	/for i 1 to ${netbotCount}
		/varset netbotName ${NetBots.Client[${i}]}	
		/if (${NetBots[${netbotName}].Attacking}==TRUE && ${NetBots[${netbotName}].TargetID}==${targetID}) /return TRUE
	/next i

	/RETURN FALSE
}

SUB processCommandLine() {
	/if (${commandLine[${cmdDEBUG}].NotEqual[-]}) /varset debugMode TRUE

	/if (${commandLine[${cmdINI}].Length}>0) /varset commandLine[${cmdINI}] -${commandLine[${cmdINI}]}

	/if (${commandLine[${cmdDIRECTINI}].Length}>0) {
		/varset botIniFile p3_bots\${commandLine[${cmdDIRECTINI}]}.ini
	} else {
		/varset botIniFile p3_bots\${MacroQuest.Server}-${Me.CleanName}${commandLine[${cmdINI}]}.ini
	}

	/RETURN
}

SUB getDefaultBCSChannels() {
	/declare ret list local
	/declare retstr string local
	/declare i int local

	/invoke ${ret.Append[${Me.Class.Name.Lower}s]}
	/if (${meleeClasses.Find[${Me.Class.ShortName}]}!=NULL) {
		/invoke ${ret.Append[melee]}
	}
	/if (${tankClasses.Find[${Me.Class.ShortName}]}!=NULL) {
		/invoke ${ret.Append[tanks]}
	}
	/if (${rangedClasses.Find[${Me.Class.ShortName}]}!=NULL) {
		/invoke ${ret.Append[ranged]}
	}
	/if (${priestClasses.Find[${Me.Class.ShortName}]}!=NULL) {
		/invoke ${ret.Append[healers]}
	}

	/for i 0 to ${Math.Calc[${ret.Count}-1]}
		/varset retstr ${ret.Item[${i}]} ${retstr}
	/next i

	/RETURN ${retstr.Left[-1]}
}

SUB fullTarget(int targetID) {
	/if (${Target.ID} != ${targetID}) {
		/tar id ${targetID}
		/delay 5
	}

	/RETURN

	/target clear
	/delay 2
	
	/while (${Target.BuffsPopulated}==0 && ${Target.BuffsPopulated}!=NULL) {
		/if (${Target.ID}!=${targetID}) /tar id ${targetID}
		/delay 1
	}

	/RETURN
}


SUB checkOpenWindows() {
	/if (${Window[BigBankWnd].Open})	 /return TRUE
	/if (${Window[TradeWnd].Open})		/return TRUE
	/if (${Window[GuildBankWnd].Open})  /return TRUE
	/if (${Window[MerchantWnd].Open})	/return TRUE
	/if (${Window[SpellBookWnd].Open})  /return TRUE
	/return FALSE
}

SUB waitForInt(string eval, int result) {
   :loopstart
      /doevents
      /delay 1
      /if (${stopWait}) {
         /varset stopWait FALSE
         /return
      }
      /if (${${eval}}!=${result}) /goto :loopstart
	/RETURN
}

SUB waitForBool(string eval, bool result, string docmd)
	/echo waitfor bool: ${eval}
   :loopstart
      /doevents
      /delay 2
      /if (${stopWait}) {
         /varset stopWait FALSE
         /return
      }
      /if (${docmd.Length}>0) /docommand ${docmd}
      /if (${${eval}}!=${result}) /goto :loopstart
/RETURN
SUB p3_heals_init {
	/call p3RegisterCommand TAGSCHANGED healsTagsChanged 50


	/declare healsEnabled bool outer TRUE
	/declare healCheckTimer timer outer 0
	/declare teamIndex int outer 0
	/declare enableteamIndex bool outer TRUE
	/declare checkTeamIndexTimer timer outer 0
	/declare refreshHealTableTimer timer outer 0

	/declare HT_NETBOT int outer 1
	/declare HT_GROUP int outer 2
	/declare HT_XTAR int outer 4
	/declare HT_NETPET int outer 8
	|/declare HT_MYPET int outer 16

	/declare healthTable list outer

	/declare castTeamNetbots string outer NONE
	/declare castTeamNetbotsList list outer

	/declare autoRezEnabled bool outer FALSE
	/declare autoRezSpells string outer NONE
	/declare autoRezRequireTeamIndex int outer 0

	/varset autoRezEnabled ${getBotIniOption[Misc.AutoRezEnabled,${autoRezEnabled}]}
	/varset autoRezSpells ${getBotIniOption[Misc.AutoRezSpells,${autoRezSpells}]}
	/varset autoRezRequireTeamIndex ${getBotIniOption[Misc.AutoRezTeamIndex,${autoRezRequireTeamIndex}]}

	/varset castTeamNetbots ${getBotIniOption[CastTeam.Members,${castTeamNetbots}]}
	/invoke ${castTeamNetbotsList.Append[${castTeamNetbots.Upper}]}
	/invoke ${castTeamNetbotsList.Remove[${Me.CleanName.Upper}]}

	/call processArrayTargets iniHeals
	/call validateTagsFromArray iniHeals

	/RETURN
}

SUB healsTagsChanged() {
	/call validateTagsFromArray iniHeals
	/RETURN
}

SUB healsMaintenance() {
	/if (${healsEnabled}==FALSE) /RETURN

	/if (${castTeamNetbots.NotEqual[NONE]} &&  ${Math.Calc[${Time.Second} % 5]}==0 && ${checkTeamIndexTimer}==0) {
		/varset checkTeamIndexTimer 5s
		/call determineTeamIndex
	}

	/if (${healCheckTimer}==0) {
		/varset healCheckTimer 5
		
		/call determineTeamIndex

		/if (${Me.Casting.ID}!=NULL) /return
		/if (${Me.Invis}==TRUE) /RETURN
		/if (${Me.Silenced.ID}!=NULL) /RETURN
		/if ((${Me.Moving}==TRUE || ${movingTimer} > 0) && ${canCastWhileMoving}==FALSE) /return

		/call checkHeals

		/if (${Macro.Return}==TRUE) /RETURN RESET

		/if (${autoRezEnabled}==TRUE) {
			/call checkAutoRez
		}
	}


	/RETURN
}

SUB checkHeals {
	/declare i int local
	/declare cancelConditions string local
	/declare healTargetName string local
	/declare healSpawn spawn local
	/declare healSpellName string local
	/declare healSpell spell local
	/declare healPct int local 90
	/declare useTeamIndex bool local FALSE
	/declare checkSpellID int local
	/declare healLockoutTimerName string local
	/declare triggerIdleCasting bool local TRUE
	/declare cancelHealHP int local 
	/declare botBuffIDs list local 
	/declare netbotsReadyForHeal list local
	/declare healMask int local ${Math.Calc[${HT_NETBOT}|${HT_GROUP}]}
	/declare getHealthTableIndex int local 1
	/declare actionTaken bool local FALSE
	/declare targetType string local -

	/invoke ${botBuffIDs.Delimiter[ ]}

	/call refreshHealTables

	/for i 1 to ${iniHeals.Size}
		/varset healMask 3
		/varset triggerIdleCasting TRUE
		/varset cancelConditions
		/varset getHealthTableIndex 0
		/invoke ${botBuffIDs.Clear}
		/invoke ${netbotsReadyForHeal.Clear}

		/if (${iniHeals[${i},1].Equal[-]}) /break
		/if (${iniHeals[${i},${bEnabled}].Equal[NO]}) /continue
		/if (${iniHeals[${i},${bTagsInvalidated}].Equal[YES]}) /continue

		/varset healSpellName ${iniHeals[${i},1]}

		/if (${iniHeals[${i},${bRequireCastIdle}].NotEqual[-]}) {
			/if (${idleCastingTimer}>0) /continue
			/varset triggerIdleCasting FALSE
		}

		/if (${iniHeals[${i},${bGiftOfMana}].NotEqual[-]}) {
			/if (${Me.Song[Gift Of Mana].ID}==NULL) /continue
		}

		/if (${iniHeals[${i},${bMyName}].NotEqual[-]}) {
			/if (${Me.CleanName.Upper.NotEqual[${iniHeals[${i},${bMyName}].Upper}]}) /continue
		}

		/if (${iniHeals[${i},${bRequireTeamIndex}].NotEqual[-]}) {
			/if (${teamIndex}!=${iniHeals[${i},${bRequireTeamIndex}]}) /continue
		}

		/if (${iniHeals[${i},${bNotIfMounted}].NotEqual[-]}) {
			/if (${Me.Mount.ID}!=NULL) /continue
		}

		/if (${iniHeals[${i},${bCastableOnlyResting}].NotEqual[-]}) {
			/if (${Me.CombatState.Equal[COMBAT]}) /continue
		}

		/if (${iniHeals[${i},${bSelfOverHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} < ${iniHeals[${i},${bSelfOverHP}]}) /continue
		}

		/if (${iniHeals[${i},${bSelfUnderHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} >= ${iniHeals[${i},${bSelfUnderHP}]}) /continue
		}

		/if (${iniHeals[${i},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} < ${iniHeals[${i},${bSelfOverMana}]}) /continue
		}

		/if (${iniHeals[${i},${bSelfUnderMana}].NotEqual[-]}) {
			/if (${Me.PctMana} >= ${iniHeals[${i},${bSelfUnderMana}]}) /continue
		}

		/if (${iniHeals[${i},${bRequireMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 40]} < ${iniHeals[${i},${bRequireMobsInProximity}]}) /continue
		}

		/if (${iniHeals[${i},${bRequireMaxMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 75]} > ${iniHeals[${i},${bRequireMaxMobsInProximity}]}) /continue
		}

		/if (${iniHeals[${i},${bRequireHurtPartyMembers}].NotEqual[-]}) {
			/if (${checkHurtPartyMembers[${iniHeals[${i},${bRequireHurtPartyMembers}]},45]}==FALSE) /continue
		}

		/if (${iniHeals[${i},${bUseTeamIndex}].NotEqual[-]}) {
			/varset useTeamIndex TRUE
		} else {
			/varset useTeamIndex FALSE
		}

		/if (${iniHeals[${i},${bHealPct}].NotEqual[-]}) /varset healPct ${iniHeals[${i},${bHealPct}]}

		/call getSpellFromCastRequest "${healSpellName}"
		/if (${Macro.Return.Equal[UNKNOWN]}) {
			/bc Warning: checkHeals() getSpellFromCastRequest() returned UNKNOWN for (${healSpellName}). Not sure what to do.
			/RETURN
		} else /if (${Macro.Return.Equal[ABILITY]}) {
			/bc Warning: checkHeals() Abilities are not allowed as heal entries.
			/RETURN
		} else {
			/vardata healSpell ${Macro.Return}
		}

		/varset targetType ${healSpell.TargetType.Upper}

		/if (${iniHeals[${i},${bForceTargetType}].NotEqual[-]}) {
			/varset targetType ${iniHeals[${i},${bForceTargetType}].Upper}
		}

		/if (${targetType.Equal[SELF]}) {
			/if (${Me.PctHPs}>${healPct}) /continue
			/vardata healSpawn Spawn[id ${Me.ID}]
		} else {
			/if (${iniHeals[${i},${bUseTeamIndex}].NotEqual[-]}) /varset getHealthTableIndex ${teamIndex}

			/if (${iniHeals[${i},${bIncludeNetBotPets}].NotEqual[-]}) /varset healMask ${Math.Calc[${healMask}|${HT_NETPET}].Int}
			/if (${iniHeals[${i},${bIncludeXTargets}].NotEqual[-]}) /varset healMask ${Math.Calc[${healMask}|${HT_XTAR}].Int}
			/if (${iniHeals[${i},${bOnlyXTargets}].NotEqual[-]}) /varset healMask ${HT_XTAR}
			/if (${iniHeals[${i},${bOnlyNetBotPets}].NotEqual[-]}) /varset healMask ${HT_NETPET}
			
			/call getHealthTableEntry ${getHealthTableIndex} ${healMask} ${healPct} ${i}

			/if (${Macro.Return.Equal[-]}) /continue

			/if (${Macro.Return.Length}==0) {
				/echo ${getHealthTableIndex} ${healMask} ${healPct} ${i}
			}

			/vardata healSpawn Spawn[=${Macro.Return}]
		}

		/varset healLockoutTimerName heal_${healSpawn.ID}_${healSpellName}
		/if (${isLockoutExpired[heal_${healSpawn.ID}_${healSpell.ID}]}==FALSE) /continue

		/if (${healSpawn.Distance3D} > ${healSpell.MyRange} && ${healSpawn.Distance3D} > ${healSpell.AERange}) /continue

		/if (${iniHeals[${i},${bNotIfShortBuff}].NotEqual[-]}) {
			/varset checkSpellID ${Spell[${iniHeals[${i},${bNotIfShortBuff}]}].ID}
			/if (${Select[${checkSpellID},${NetBots[${healSpawn.Name}].ShortBuff}]}>0) /continue
		}

		/if (${healSpell.Duration}>0) {
			/invoke ${botBuffIDs.Append[${NetBots[${healSpawn.Name}].ShortBuff}
			/invoke ${botBuffIDs.Append[${NetBots[${healSpawn.Name}].Buff}
			/if (${botBuffIDs.Contains[${healSpell.ID}]}==TRUE) /continue
			/varset cancelConditions TARGETHASBUFF:${healSpell.Name}|
		}

		/if (${iniHeals[${i},${bCancelAtHP}].NotEqual[-]}) {
			/varset cancelHealHP ${iniHeals[${i},${bCancelAtHP}]}
			/if (${cancelHealHP}==0) /varset cancelHealHP ${healPct}
			/varset cancelConditions TARGETOVERHP:${cancelHealHP}|${cancelConditions}
		}

		/if (${iniHeals[${i},${bNoCancelChecks}].NotEqual[-]}) {
			/varset cancelConditions
		}

		/if (${iniHeals[${i},${bMemInGem}].NotEqual[-]} && ${Me.Gem[${healSpellName}]}==NULL) {
			/call memorizeSpellInGem "${healSpellName}" ${iniHeals[${i},${bMemInGem}]}
		}

		/if (${isCastReady[${healSpellName}]}==FALSE) {
			/continue
		}

		/if (${iniHeals[${i},${bDoCommand}].NotEqual[-]}) /docommand ${iniHeals[${i},${bDoCommand}]}

		/bc ${healSpellName} => ${healSpawn}  (MTI: ${teamIndex})  RTI? ${iniHeals[${i},${bRequireTeamIndex}]} (Pct: ${iniHeals[${i},${bHealPct}]})
		/invoke (${cq.Append[CAST;SPELL=${healSpellName};HEALSPELLID=${healSpell.ID};TARGETID=${healSpawn.ID};CANCELCONDITIONS=${cancelConditions.Left[-1]};SRC=iniHeals;SRCIDX=${i}]})
		/RETURN TRUE

	/next i

	/RETURN FALSE
}

SUB refreshHealTables {
	|/if (${refreshHealTableTimer}>0) /return
	|/varset refreshHealTableTimer 3

	/declare i int local
	/declare m int local
	/declare netbotName string local
	/declare netbotCount ${NetBots.Counts}
	/declare trackIDs list local
	/declare spawnID int local
	/declare searchIndex int local
	/declare mask int local

	/invoke ${healthTable.Clear}

	/for i 1 to ${netbotCount}
		/varset netbotName ${NetBots.Client[${i}]}
		/if (${netbotName.Equal[NULL]}) /break
		/if (${NetBots[${netbotName}].InZone}==NULL) /continue
		/if (${Spawn[pc =${netbotName}].ID}==NULL) /continue
		/if (${Spawn[pc =${netbotName}].Dead}==TRUE) /continue
		/if (${NetBots[${netbotName}].State.Equal[DEAD]}==TRUE || ${NetBots[${netbotName}].State.Equal[STUN]} && ${NetBots[${netbotName}].CurrentHPs} < -1) /continue
		/if (${NetBots[${netbotName}].Invulnerable}==1) /continue

		/invoke ${healthTable.Append[${strPad[${NetBots[${netbotName}].PctHPs}]}:${netbotName}:1]}
		/invoke ${trackIDs.Append[${NetBots[${netbotName}].ID}]}

		/if (${NetBots[${netbotName}].PetID}!=NULL) {
			/invoke ${healthTable.Append[${strPad[${NetBots[${netbotName}].PetHP}]}:${Spawn[id ${NetBots[${netbotName}].PetID}].CleanName}:8]}
			/invoke ${trackIDs.Append[${NetBots[${netbotName}].PetID}]}
		}
	/next i

	|/if (${Me.Grouped}==TRUE) {
	|	/for i 0 to ${Group.Members}
	|		/if (${Spawn[group =${Group.Member[${i}]}].ID}==NULL) /continue
	|		/if (${Spawn[group =${Group.Member[${i}]}].Dead}==TRUE) /continue
	|
	|		/varset spawnID ${Spawn[group =${Group.Member[${i}]}].ID}
	|		/varset searchIndex ${trackIDs.Index[${spawnID}]}
	|		/if (${searchIndex}==-1) {
	|			/invoke ${healthTable.Append[${strPad[${Group.Member[${i}].PctHPs}]}:${Group.Member[${i}].Name}:2]}
	|			/invoke ${trackIDs.Append[${spawnID}]}
	|		}
	|	/next i
	|}

	/for i 1 to 12
		/if (${Me.XTarget[${i}].ID}==NULL) /continue
		/if (${Me.XTarget[${i}].ID}==0) /continue
		/if (${Me.XTarget[${i}].Type.NotEqual[PC]} && ${Me.XTarget[${i}].Type.NotEqual[Pet]}) /continue
		/if (${Me.XTarget[${i}].Type.Equal[Pet]} && ${Me.XTarget[${i}].Master.Type.NotEqual[PC]}) /continue

		/varset spawnID ${Me.XTarget[${i}].ID}
		/varset searchIndex ${trackIDs.Index[${spawnID}]}
		/if (${searchIndex}==-1) {
			/invoke ${healthTable.Append[${strPad[${Me.XTarget[${i}].PctHPs}]}:${Me.XTarget[${i}].CleanName}:4]}
			/invoke ${trackIDs.Append[${spawnID}]}
		}
	/next i

	/invoke ${healthTable.Sort}

	|/echo ===== ${healthTable.Count}

	/for i 0 to ${Math.Calc[${healthTable.Count}-1]} {
		|/echo ${healthTable.Item[${i}]}
	/next i

	/RETURN
}

SUB strPad(string i) {
	/if (${i}>99) /return ${i}
	/if (${i}>9 && ${i}<100) /return 0${i}
	/if (${i}<9 && ${i}>0) /return 00${i}
	/if (${i}<0) /return 000

	/echo OOPS: ${i}
	|/beep
	/RETURN 000
}

SUB onHealCastComplete(string result, string opts) {
	/declare i int local ${getStackCommandOpt[${opts},SRCIDX]}
	/declare targetID int local ${getStackCommandOpt[${opts},TARGETID]}
	/declare healSpellID ${getStackCommandOpt[${buffSpellName},HEALSPELLID]}

	/if (${iniHeals[${i},${bRecastDelay}].NotEqual[-]}) {
		/call lockout heal_${targetID}_${healSpellID} ${iniHeals[${i},${bRecastDelay}]}
	}

	/RETURN
}

SUB checkHurtPartyMembers(string params, int distanceLimit)
	/declare requireHurtChars int local ${params.Token[1,@]}
	/declare requireHealthPct int local ${params.Token[2,@]}
	/declare hurtChars int local 0

	/if (${Me.Grouped}==FALSE) /return FALSE

	/declare i int local 0
	/for i 0 to ${Group.Members}
		/if (${Spawn[group =${Group.Member[${i}]}].ID}==NULL) /continue
		/if (${Spawn[group =${Group.Member[${i}]}].Dead}==TRUE) /continue

		/if (${distanceLimit} > 0 && ${Spawn[group =${Group.Member[${i}]}].Distance3D} > ${distanceLimit}) /continue
		/if (${Group.Member[${i}].PctHPs} > ${requireHealthPct}) /continue

		/varset hurtChars ${Math.Calc[${hurtChars}+1]}
	/next i

	/if (${hurtChars}>= ${requireHurtChars}) /return TRUE

	/return FALSE
/RETURN

SUB getHealthTableEntry(int teamIndexOffset, string mask, string pctHP, int iniIndex) {
	/declare i int local 
	/declare hp string local
	/declare name string local
	/declare m string local
	/declare e string local
	/declare matchCount int local 

	/varset teamIndexOffset ${Math.Calc[${teamIndexOffset}+1]}

	/for i 0 to ${Math.Calc[${healthTable.Count}-1]}
		/varset e ${healthTable.Item[${i}]}

		/varset name ${e.Token[2,:]}
		/varset m ${e.Token[3,:]}
		/varset hp ${e.Token[1,:]}

		/if (${hp}>${pctHP}) /continue

		/if (${Math.Calc[${mask}&${m}]}==0) /continue

		/if (${m} == 1 && ${iniHeals[${iniIndex},${bTargets}].NotEqual[-]}) {
			/if (${Select[${name},${iniHeals[${iniIndex},${bTargets}]}]}==0) /continue
		}

		/if (${iniHeals[${iniIndex},${bCheckShortBuffs}].NotEqual[-]}) {
			/if (${Math.Calc[${mask}&1]}==0) /continue
			/call getSpellFromCastRequest "${iniHeals[${iniIndex},1]}"
			/if (${Macro.Return.Equal[UNKNOWN]}) /continue
			/if (${NetBots[${name}].ShortBuff.Find[${${Macro.Return}.ID}]}!=0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireDiseased}].NotEqual[-]}) {
			/if (${Math.Calc[${mask}&1]}==0) /continue
			/if (${NetBots[${name}].Diseased} == 0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequirePoisoned}].NotEqual[-]}) {
			/if (${Math.Calc[${mask}&1]}==0) /continue
			/if (${NetBots[${name}].Poisoned} == 0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireCursed}].NotEqual[-]}) {
			/if (${Math.Calc[${mask}&1]}==0) /continue
			/if (${NetBots[${name}].Cursed} == 0) /continue
		}

		| bRequireHurtPartyMembers implies group memeber, so verify
		/if (${iniHeals[${iniIndex},${bRequireHurtPartyMembers}].NotEqual[-]}) {
			/if (${Spawn[group =${name}].ID}==NULL) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireGroup}].NotEqual[-]}) {
			/if (${Spawn[group =${name}].ID}==NULL) /continue
		}

		/if (${iniHeals[${iniIndex},${bTargetUnderLevel}].NotEqual[-]}) {
			/if (${Spawn[=${name}].Level} >= ${iniHeals[${iniIndex},${bTargetUnderLevel}]}) /continue
		}

		/if (${iniHeals[${iniIndex},${bTargetOverLevel}].NotEqual[-]}) {
			/if (${Spawn[=${name}].Level} <= ${iniHeals[${iniIndex},${bTargetOverLevel}]}) /continue
		}

		/varset matchCount ${Math.Calc[${matchCount}+1]}
		/if (${matchCount}==${teamIndexOffset}) {
			/return ${name}
		}
	/next i

	/RETURN -
}

SUB getNetBotReadyForHeal(int healPct, int iniIndex)
	/declare i int local 0
	/declare netbotName string local
	/declare netbotCount int local ${NetBots.Counts}
	/declare lowestPct int local 100
	/declare healNames list local
	/declare li listiterator local
	/declare b string local
	/declare grpMemID int local
	
	/if (${iniHeals[${iniIndex},${bIncludeXTargets}].NotEqual[-]} || ${iniHeals[${iniIndex},${bOnlyXTargets}].NotEqual[-]})  {
		/for i 1 to 12
			/if (${Me.XTarget[${i}].ID}==NULL) /continue
			/if (${Me.XTarget[${i}].ID}==0) /continue
			/if (${Me.XTarget[${i}].Type.NotEqual[PC]} && ${Me.XTarget[${i}].Type.NotEqual[Pet]}) /continue
			/if (${Me.XTarget[${i}].Type.Equal[Pet]} && ${Me.XTarget[${i}].Master.Type.NotEqual[PC]}) /continue
			/if (${Me.XTarget[${i}].PctHPs} <= ${healPct}) {
				/if (${healNames.Index[${Me.XTarget[${i}].CleanName}]}!=-1) /continue
				/if (${isLockoutExpired[heal_${Me.XTarget[${i}].ID}_${iniHeals[${iniIndex},1]}]}==FALSE) /continue

				/if (${Me.XTarget[${i}].PctHPs}<${lowestPct}) {
					/varset lowestPct ${Me.XTarget[${i}].PctHPs}
					/invoke ${healNames.Insert[0,${Me.XTarget[${i}].CleanName}]}
				} else {
					/invoke ${healNames.Append[${Me.XTarget[${i}].CleanName}]}
				}
			}
		/next i
	}

	/if (${iniHeals[${iniIndex},${bOnlyXTargets}].NotEqual[-]}) /goto :doneWithNames

	/varset lowestPct 100
	/if (${Me.Grouped}==TRUE && ${iniHeals[${iniIndex},${bIncludeGroup}].NotEqual[-]}) {
		/for i 1 to 5
			/varset grpMemID ${Spawn[group =${Group.Member[${i}]}].ID}
			/if (${Spawn[id ${grpMemID}].ID}==NULL) /continue
			/if (${Group.Member[${i}].PctHPs} > ${healPct}) /continue
			/if (${healNames.Contains[${Group.Member[${i}]}==FALSE) /continue				
			/if (${isLockoutExpired[heal_${grpMemID}_${iniHeals[${iniIndex},1]}]}==FALSE) /continue

			/if (${Group.Member[${i}].PctHPs}<=${lowestPct}) {
				/varset lowestPct ${Group.Member[${i}].PctHPs}
				/invoke ${healNames.Insert[0,${Group.Member[${i}]}]}
			} else {
				/invoke ${healNames.Append[${Group.Member[${i}]}]}
			}
		/next i
	}

	/varset lowestPct 100
	/for i 1 to ${netbotCount}
		/varset netbotName ${NetBots.Client[${i}]}

		/if (${netbotName.Equal[NULL]}) /break

		/if (${NetBots[${netbotName}].InZone} == FALSE) /continue

		/if (${Spawn[${netbotName}].Dead}==TRUE) /continue

		/if (${NetBots[${netbotName}].State.Equal[DEAD]}==TRUE || ${NetBots[${netbotName}].State.Equal[STUN]} && ${NetBots[${netbotName}].CurrentHPs} < -1) /continue

		/if (${NetBots[${netbotName}].Invulnerable}==1) /continue

		/if (${iniHeals[${iniIndex},${bTargets}].NotEqual[-]}) {
			/if (${Select[${netbotName},${iniHeals[${iniIndex},${bTargets}]}]}==0) /continue
		}

		/if (${iniHeals[${iniIndex},${bCheckShortBuffs}].NotEqual[-]}) {
			/call getSpellFromCastRequest "${iniHeals[${iniIndex},1]}"
			/if (${Macro.Return.Equal[UNKNOWN]}) /continue
			/if (${NetBots[${netbotName}].ShortBuff.Find[${${Macro.Return}.ID}]}!=0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireGroup}].NotEqual[-]}) {
			/if (${Spawn[group =${netbotName}].ID}==NULL) /continue
		}

		/if (${iniHeals[${iniIndex},${bTargetUnderLevel}].NotEqual[-]}) {
			/if (${NetBots[${netbotName}].Level} >= ${iniHeals[${iniIndex},${bTargetUnderLevel}]}) /continue
		}
		/if (${iniHeals[${iniIndex},${bTargetOverLevel}].NotEqual[-]}) {
			/if (${NetBots[${netbotName}].Level} <= ${iniHeals[${iniIndex},${bTargetOverLevel}]}) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireDiseased}].NotEqual[-]}) {
			/if (${NetBots[${netbotName}].Diseased} == 0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequirePoisoned}].NotEqual[-]}) {
			/if (${NetBots[${netbotName}].Poisoned} == 0) /continue
		}

		/if (${iniHeals[${iniIndex},${bRequireCursed}].NotEqual[-]}) {
			/if (${NetBots[${netbotName}].Cursed} == 0) /continue
		}

		| bRequireHurtPartyMembers implies group memeber, so verify
		/if (${iniHeals[${iniIndex},${bRequireHurtPartyMembers}].NotEqual[-]}) {
			/if (${Spawn[group =${netbotName}].ID}==NULL) /continue
		}

		/if (${NetBots[${netbotName}].PctHPs} <= ${healPct}) {
			/if (${healNames.Contains[${netbotName}]}==TRUE) /continue
			/if (${NetBots[${netbotName}].PctHPs} < ${lowestPct}) {
				/varset lowestPct ${NetBots[${netbotName}].PctHPs}
				/invoke ${healNames.Insert[0,${netbotName}]}
			} else {
				/invoke ${healNames.Append[${netbotName}]}
			}
		}
	/next i

	:doneWithNames

	/if (${healNames.Count}==0) /return NONE

	/vardata li healNames.First
	/while (${li.IsEnd}==FALSE) {
		/varset b ${b}${li.Value}
		/invoke ${li.Advance}
		/if (${li.IsEnd}==TRUE) /break
		/varset b ${b},
	}

	/return ${b}
/RETURN

SUB determineTeamIndex
	/if (${castTeamNetbots.Equal[NONE]}) /return

	/declare i int local
	/declare j int local
	/declare entryCount int local ${castTeamNetbotsList.Count}
	/declare entryName string local
	/declare myManaAmount int local
	/declare entryManaAmount int local

	/declare highMana int local 101


	| RESET TO 1 FOR THIS SCAN
	/varset teamIndex ${Math.Calc[${entryCount}]} 

	|/if (${Me.Stunned}==TRUE || ${Me.SpellInCooldown}==TRUE) {
	|   /varset teamIndex 100
	|   /return
	|}


	/for i 0 to ${Math.Calc[${entryCount}-1]}
		/varset entryName ${castTeamNetbotsList.Item[${i}]}
		/varset entryName ${entryName.Left[1]}${entryName.Right[-1].Lower}

		|/varset myManaAmount ${Me.CurrentMana}
		|/varset entryManaAmount ${NetBots[${entryName}].CurrentMana}
		/varset myManaAmount ${Me.PctMana}
		/varset entryManaAmount ${NetBots[${entryName}].PctMana}

		| ARE THEY CASTING SOMETHING? BUMP ME UP
		|/if (${Bool[${NetBots[${entryName}].Casting}]}==TRUE) {
		|   /varset teamIndex ${Math.Calc[${teamIndex}-1]}
		|   /continue
		|}

		/if (${NetBots[${entryName}].InZone}==FALSE) {
			/varset teamIndex ${Math.Calc[${teamIndex}-1]}
			/continue
		}

		| IS ANOTHER NETBOT STUNNED OR DEAD? INCREASE MY PRIORITY
		/if (${Select[${NetBots[${entryName}].State},DEAD,HOVER]}>0) {
			/varset teamIndex ${Math.Calc[${teamIndex}-1]}
			/continue
		}

		| DOES MY MANA MATCH ANOTHER EXACTLY? ONE OF US NEEDS TO DEFER - USE ID AS A SEQUENTIAL DIFFERENTIATOR
		/if (${entryManaAmount}==${myManaAmount}) {
			| IF MY ID IS HIGHER THAN THEIR ID, INCREASE MY PRI
			/if (${Me.ID}>${Spawn[PC ${entryName}].ID}) {
				/varset teamIndex ${Math.Calc[${teamIndex}-1]}
			}
		} else /if (${myManaAmount} > ${entryManaAmount}) {
			/varset teamIndex ${Math.Calc[${teamIndex}-1]}
		}
	/next i

/RETURN


SUB checkAutoRez() {
	/if (${Me.Moving}==TRUE) /RETURN
	/if (${Stick.Active}==TRUE) /RETURN
	/if (${Me.Silenced.ID}!=NULL) /RETURN
	/if (${Me.Invis}==TRUE) /RETURN
	/if (${Me.Casting.ID}!=NULL) /RETURN

	/declare xSpawnID int local
	/declare corpseSearch string local pccorpse radius 150
	/declare useRezSpell string local
	/declare x int local
	/declare allcorpses[100] spawn local
	/declare corpseCount int local
	/declare readyRezSpell string local


	/if (${autoRezRequireTeamIndex}!=0) {
		/if (${teamIndex}<${autoRezRequireTeamIndex}) /return
	}

	/call getReadyRezSpell
	/varset readyRezSpell ${Macro.Return}
	/if (${readyRezSpell.Equal[-]}) /return
	/if (${isCastReady[${readyRezSpell}]}==FALSE) /return

	/vardata corpseCount SpawnCount[${corpseSearch}]
	/if (${corpseCount}==0) /return FALSE

	/for x 1 to ${corpseCount}
		/echo check: rez_${NearestSpawn[${x},${corpseSearch}].ID}  ${NearestSpawn[${x},${corpseSearch}]}
		/if (${isLockoutExpired[rez_${NearestSpawn[${x},${corpseSearch}].ID}]}==FALSE) {
			/continue
		} else {
			/varset xSpawnID ${NearestSpawn[${x},${corpseSearch}].ID}
			/break
		}
	/next x

	/if (${xSpawnID}==NULL) /return

	/bc AutoRez:  ${xSpawnID} ${Spawn[id ${xSpawnID}].Name}
	/invoke (${cq.Append[CAST;SPELL=${readyRezSpell};TARGETID=${xSpawnID};ONRESULT=onRezCastResult;]})
	
	/RETURN
}

SUB onRezCastResult(string result, string opts) {

	/if (${result.Find[PASS_]}!=NULL) {
		/echo create lockout: rez_${xSpawnID}
		/call lockout rez_${xSpawnID} 45s
	}
	
	/RETURN
}

SUB getReadyRezSpell() {
	/declare i int local 

	/if (${autoRezSpells.Find[,]}==0) {
		/if (${isCastReady[${autoRezSpells}]}==FALSE) {
			/return -
		} else {
			/return ${autoRezSpells}
		}
	} else {
		/for i 1 to ${Math.Calc[${autoRezSpells.Count[,]}+1]}
			/if (${isCastReady[${autoRezSpells.Token[${i},,]}]}==TRUE) {
				/return ${autoRezSpells.Token[${i},,]}
			}
		/next i
	}

	/RETURN -
}

SUB p3_meleecombat_init {
	/call p3RegisterCommand KILL meleecombatKill 55
	/call p3RegisterCommand STOP meleecombatStop 50
	/call p3RegisterCommand FOLLOW meleecombatFollow 50
	/call p3RegisterCommand ROAMMOVESTART meleecombatRoamMoveStart 45

	/declare meleeTargetID int outer 0

	/declare useMeleeCombat bool outer 				${Bool[${Select[${Me.Class.ShortName},${defaultMeleeCombatClasses}]}]}
	/declare meleeRetreatPct int outer 				45
	/declare meleeRetreatResumePct int outer 		80

	/varset useMeleeCombat 				${getBotIniOption[Assist.UseMeleeCombat,${useMeleeCombat}]}

	/RETURN
}

SUB meleecombatRoamMoveStart(string cmd, string opts) {
	/call meleecombatStop
	/RETURN
}

SUB meleecombatFollow(string cmd, string opts) {
	/call meleecombatStop
	/RETURN
}

SUB meleecombatKill(string cmd, string opts) {
	/varset meleeTargetID ${getStackCommandOpt[${opts},SPAWNID]}

	/RETURN
}

SUB meleecombatStop(string cmd, string opts) {
	/varset meleeTargetID 0
	/attack off

	/RETURN
}

SUB meleecombatMaintenance() {
	/declare killSpawn spawn local 

	/if (${meleeTargetID}==0) {
		/if (${Me.Combat}==TRUE) /attack off
		/return
	}

	/if (${Spawn[id ${meleeTargetID}].ID}==NULL || ${Spawn[id ${meleeTargetID}].Dead}==TRUE) {
		/call meleecombatStop
		/return
	}

	/vardata killSpawn Spawn[id ${meleeTargetID}]

	/if (${killSpawn.ID}==NULL || ${killSpawn.Dead}==TRUE) {
		/call meleecombatStop
		/return
	}

	/if (${useMeleeCombat}==TRUE) {
		/if (${killSpawn.Distance} > ${Math.Calc[${killSpawn.MaxRangeTo}+0.5]}) {
			/if (${Me.Combat}==TRUE) /attack off
		} else {
			/if (${Me.Combat}==FALSE) /attack on
		}
	}

	/RETURN
}

SUB p3_mine_init() {
	/call p3RegisterCommand KILL onMineKillCommand 60
	
    /declare rogSneakEnabled bool outer FALSE

	/declare advPathPresent bool outer FALSE
	/if (${Plugin[MQ2AdvPath].Name.Length}!=NULL) /varset advPathPresent TRUE

    /declare wuCheck bool outer TRUE
    /declare wuCheckTimer timer outer
    /declare wuRecheckTime int outer 30

	/RETURN
}

SUB mineMaintenance() {
    /if (${rogSneakEnabled}==TRUE) {
        /call checkRogSneak
    }

    /if (${Me.Class.ShortName.Equal[MNK]} && ${wuCheck}==TRUE) {
        /if (${assistSpawnID}==0) /return

        /if (${Me.Invis}==FALSE && ${Me.CombatAbilityReady[Fists of Wu]}==TRUE && ${Me.ActiveDisc.ID}==NULL) {
            /if (${Me.Song[Fists of Wu].ID}==NULL || ${Me.Song[Fists of Wu].Duration.TotalSeconds}<5) {
                /call checkWu
            }
        }
    }

	/RETURN
}

SUB checkWu() {
    /if (${wuCheckTimer}>0) /return
    /varset wuCheckTimer ${wuRecheckTime}

    /declare otherMonks list local
    /declare spawnID int local
    /declare spawnName string local
    /declare i int local

    /invoke ${otherMonks.Append[${Me.CleanName}]}

    /if (${Me.Grouped}==TRUE) {
        /for i 0 to 6
            /if (${Group.Member[${i}].Index}==NULL) /continue
            /varset spawnName ${Group.Member[${i}]}
            /if (${Spawn[pc =${spawnName}].Class.ShortName.Equal[MNK]}) {
                /invoke ${otherMonks.Append[${spawnName}]}
            }
        /next i
    }

    /declare topEndMonkName string local
    /declare topEndMonkAmt 0

    /echo ${otherMonks.Count}

    /for i 0 to ${Math.Calc[${otherMonks.Count}-1]} {
        /echo ${otherMonks.Item[${i}]} ${NetBots[${otherMonks.Item[${i}]}].CurrentEndurance} / ${topEndMonkAmt}
        /if (${NetBots[${otherMonks.Item[${i}]}].CurrentEndurance}>${topEndMonkAmt}) {
            /varset topEndMonkName ${otherMonks.Item[${i}]}
            /varset topEndMonkAmt ${NetBots[${otherMonks.Item[${i}]}].CurrentEndurance}
        }
    /next i

    /bc top monk: ${topEndMonkName} / ${topEndMonkAmt}

    /if (${topEndMonkName.Equal[${Me.CleanName}]}) {
        /disc fists of wu
        /delay 3
    }

    /RETURN
}


SUB onMineKillCommand(string cmd, string opts) {
    /if (${advPathPresent}==TRUE) /afollow off

    /if (${Me.Class.ShortName.Equal[ROG]}) {
        /call checkRogSurpriseAttack
    }

	/RETURN
}


SUB checkRogSneak() {
    /if (${Me.Class.ShortName.NotEqual[ROG]}) /RETURN

    /if (${assistSpawnID}==0) {
        /if (${Me.Sneaking}==FALSE) /doability sneak
        /if (${Me.Invis[SOS]}==FALSE && ${Me.AbilityReady[Hide]}==TRUE) {
            /makemevisible
            /delay 3
            /doability hide
            /em steps into the shadows.
        }
    }

    /RETURN
}

SUB checkRogSurpriseAttack() {
    /if (${Me.ActiveDisc.ID}==NULL) {
        /disc daggerfall
        /delay 5
    }

    /RETURN
}


#event rogueSneakToggle "[#*#(msg)] p3 sneak #1#"
#event rogueSneakToggle "<#*#> p3 sneak #1#"
SUB event_rogueSneakToggle(string line, string newMode)
    /if (${Me.Class.ShortName.NotEqual[ROG]}) /RETURN

    /if (${newMode.Upper.Equal[ON]}) {
        /varset rogSneakEnabled TRUE
        /bc Sneak on.
    } else /if (${newMode.Upper.Equal[OFF]}) {
        /varset rogSneakEnabled FALSE
        /bc Sneak off.
    } else {
        /bc Unrecognized sneak option. Use ON or OFF.
    }
/RETURN


#Event VishDT "#*#You sense your doom approaching#*#"
Sub Event_VishDT

    /nav rwp StartVish
    /delay 1s
    /stick off
    /rsay seeking a DT cure.
    /while (${Me.Buff[Creeping Doom].ID}) {
        /if (!${Target.CleanName.Equal["mournful spirit"]}) /tar mournful spirit
        /delay 1s
        /if (${Target.Distance}>29 && ${Target.CleanName.Equal["mournful spirit"]}) /nav target
        /if (${Target.Distance}<30 && ${Target.CleanName.Equal["mournful spirit"]}) /stick id ${Target.ID} 5 
        /if (${Target.Distance}<10 && ${Target.CleanName.Equal["mournful spirit"]}) /say Shoulder my burden
    }

    /nav wp StartVish
    /rsay Success!

/return




#Event OMMMask "#*#You feel a gaze of deadly power focusing on you#*#"
    Sub EVENT_OMMMask
        /rs IT'S ME!!!!  (CH rot may miss a beat)


        /if (${Me.Class.ShortName.Equal[BRD]}) {
            /twist off
            /delay 3
        }
        
        /if (${Cast.Timing}>1) {
            /interrupt
            /stopcast
            /delay 10
        }

        /stick off
        /moveto stop

        /while (!${Me.Song[Reflective Skin].ID}) {
            /useitem "Mirrored Mask"
            /delay 10
            /rs Trying to use mask... 
            /stick off
            /moveto stop
        }
        
        /if (${Me.Class.ShortName.Equal[BRD]}) /twist
        /rs Mask click confirmed.
    /return



#event wuoff "<#1#> wu off"
#event wuoff "[#1#(msg)] wu off"
SUB EVENT_wuoff(string line, string chatSender) {
    /if (${Me.Class.ShortName.Equal[MNK]}) /bc Turning wuCheck off.
    /varset wuCheck FALSE
    /RETURN
}

#event wuon "<#1#> wu on"
#event wuon "[#1#(msg)] wu off"
SUB EVENT_wuon(string line, string chatSender) {
    /if (${Me.Class.ShortName.Equal[MNK]}) /bc Turning wuCheck on.
    /varset wuCheck TRUE

    /RETURN
}





#event Define_UquaKey "#*#The #1# must unlock the door to the next room.#*#"
SUB event_Define_UquaKey(string line, string KeyToUse)
    /rs >>^<< The ${KeyToUse} unlocks the door >>^<<
    /popup >>^<< The ${KeyToUse} unlocks the door >>^<<
/return


#event setClass_Warrior "#*#Brute force and brawn#*#"
#event setClass_Shaman "#*#cringe at the appearance of talismans#*#"
#event setClass_Beastlord "#*#Deep gashes of feral savagery#*#"
#event setClass_Necromancer "#*#Doom of death#*#"
#event setClass_Cleric "#*#Dread of celestial spirit#*#"
#event setClass_Shadowknight "#*#Dreads the strike of dead#*#"
#event setClass_Monk "#*#Focused tranquility#*#"
#event setClass_Bard "#*#Foreboding melody#*#"
#event setClass_Paladin "#*#Holy blade#*#"
#event setClass_Rogue "#*#Ignores anything behind it#*#"
#event setClass_Enchanter "#*#Mind and body vulnerable#*#"
#event setClass_Wizard "#*#Falters when struck with the power of the elements#*#"
#event setClass_Berserker "#*#Shies from heavy blades#*#"
#event setClass_Magician "#*#Summoned elements#*#"
#event setClass_Druid "#*#The creature seems weak in the face of the power of nature#*#"
#event setClass_Ranger "#*#True shots and fast blades#*#"

SUB event_setClass_Warrior
    /popup Spawn must be killed by a >>^<< WARRIOR >>^<<
    /rs Spawn must be killed by a >>^<< WARRIOR >>^<<
/return

SUB event_setClass_Shaman
    /popup Spawn must be killed by a >>^<< SHAMAN >>^<<
    /rs Spawn must be killed by a >>^<< SHAMAN >>^<<
/return

SUB event_setClass_Beastlord
    /popup Spawn must be killed by a >>^<< BEASTLORD >>^<<
    /rs Spawn must be killed by a >>^<< BEASTLORD >>^<<
/return

SUB event_setClass_Necromancer
    /popup Spawn must be killed by a >>^<< NECROMANCER >>^<<
    /rs Spawn must be killed by a >>^<< NECROMANCER >>^<<
/return

SUB event_setClass_Cleric
    /popup Spawn must be killed by a >>^<< CLERIC >>^<<
    /rs Spawn must be killed by a >>^<< CLERIC >>^<<
/return

SUB event_setClass_Shadowknight
    /popup Spawn must be killed by a >>^<< SHADOWKNIGHT >>^<<
    /rs Spawn must be killed by a >>^<< SHADOWKNIGHT >>^<<
/return

SUB event_setClass_Monk
    /popup Spawn must be killed by a >>^<< MONK >>^<<
    /rs Spawn must be killed by a >>^<< MONK >>^<<
/return

SUB event_setClass_Bard
    /popup Spawn must be killed by a >>^<< BARD >>^<<
    /rs Spawn must be killed by a >>^<< BARD >>^<<
/return

SUB event_setClass_Paladin
    /popup Spawn must be killed by a >>^<< PALADIN >>^<<
    /rs Spawn must be killed by a >>^<< PALADIN >>^<<
/return

SUB event_setClass_Rogue
    /popup Spawn must be killed by a >>^<< ROGUE >>^<<
    /rs Spawn must be killed by a >>^<< ROGUE >>^<<
/return

SUB event_setClass_Enchanter
    /popup Spawn must be killed by a >>^<< ENCHANTER >>^<<
    /rs Spawn must be killed by a >>^<< ENCHANTER >>^<<
/return

SUB event_setClass_Wizard
    /popup Spawn must be killed by a >>^<< WIZARD >>^<<
    /rs Spawn must be killed by a >>^<< WIZARD >>^<<
/return

SUB event_setClass_Berserker
    /popup Spawn must be killed by a >>^<< BERSERKER >>^<<
    /rs Spawn must be killed by a >>^<< BERSERKER >>^<<
/return

SUB event_setClass_Magician
    /popup Spawn must be killed by a >>^<< MAGICIAN >>^<<
    /rs Spawn must be killed by a >>^<< MAGICIAN >>^<<
/return

SUB event_setClass_Druid
    /popup Spawn must be killed by a >>^<< DRUID >>^<<
    /rs Spawn must be killed by a >>^<< DRUID >>^<<
/return

SUB event_setClass_Ranger
    /popup Spawn must be killed by a >>^<< RANGER >>^<<
    /rs Spawn must be killed by a >>^<< RANGER >>^<<
/return

#event startClass_Priests "#*#The creature cannot stand up to the power of healers#*#"
#event startClass_Hybrids "#*#The creature appears weak to the combined effort of might and magic#*#"
#event startClass_Casters "#*#The creature will perish under the strength of intelligent magic#*#"
#event startClass_Melees "#*#The creature appears weak to the combined effort of strength and cunning#*#"

SUB event_startClass_Priests
    /if (!${Defined[murauderKill]}) {
        /declare murauderKill int outer 3
    } else /if (${Defined[murauderKill]}) {
        /varset murauderKill 3
    }
    /rs Spawn must be killed by a >>^<< PRIEST >>^<<
/return

SUB event_startClass_Hybrids
    /if (!${Defined[murauderKill]}) {
        /declare murauderKill int outer 2
    } else /if (${Defined[murauderKill]}) {
        /varset murauderKill 2
    }
    /rs Spawn must be killed by a >>^<< HYBRID >>^<<
/return

SUB event_startClass_Casters
    /if (!${Defined[murauderKill]}) {
        /declare murauderKill int outer 1
    } else /if (${Defined[murauderKill]}) {
        /varset murauderKill 1
    }
    /rs Spawn must be killed by a >>^<< CASTER >>^<<
/return

SUB event_startClass_Melees
    /if (!${Defined[murauderKill]}) {
        /declare murauderKill int outer 4
    } else /if (${Defined[murauderKill]}) {
        /varset murauderKill 4
    }
    /rs Spawn must be killed by a >>^<< MELEE >>^<<
/return


SUB p3_movement_init {
	/call p3RegisterCommand FOLLOW movementFollowDistCheck 01
	/call p3RegisterCommand FOLLOW movementFollow 60
	/call p3RegisterCommand STOP movementStop 60
	/call p3RegisterCommand KILL movementKill 60
	/call p3RegisterCommand DROPANCHOR movementAnchor 55
	/call p3RegisterCommand RAISEANCHOR movementRaiseAnchor 55
	/call p3RegisterCommand ROAMMOVESTART movementRoamMoveStart 45

	/declare stickLockoutTimer timer outer 0
	/declare stickRoamLockoutTimer timer outer 0
	/declare feetWetStickTimer timer outer 0
	/declare anchorXYZ string outer -
	/declare needRestick bool outer FALSE
	/declare stickMode string outer -
	/declare refaceTimer timer outer 0

	/declare stickTargetID int outer 0
	/declare activeStickFlags string outer
	/declare activeStickDistance string outer
	/declare movingTimer timer outer 0
	/declare fearStartXYZ string outer -
	/declare stickStartZone int outer 0

	/declare followStickFlags string outer 			UW
	/declare followStickDistance string outer 		10
	/declare meleeStickFlags string outer 			BEHIND MOVEBACK
	/declare meleeStickDistance string outer 		10
	/declare followUseNavAssist bool outer 			TRUE
	/declare fearReturnToStart bool outer 			TRUE
	/declare feignAutoStand bool outer 				TRUE
	/declare followMaxResponseDist int outer 		500

	/varset followStickFlags ${getBotIniOption[Misc.FollowStickFlags,${followStickFlags}]}
	/varset followStickDistance ${getBotIniOption[Misc.FollowStickDistance,${followStickDistance}]}
	/varset meleeStickFlags ${getBotIniOption[Assist.MeleeStickFlags,${meleeStickFlags}]}
	/varset meleeStickDistance ${getBotIniOption[Assist.MeleeStickDistance,${meleeStickDistance}]}
	/varset followUseNavAssist ${getBotIniOption[Assist.FollowUseNavAssist,${followUseNavAssist}]}
	/varset fearReturnToStart ${getBotIniOption[Misc.FearReturnToStart,${fearReturnToStart}]}
	/varset feignAutoStand ${getBotIniOption[Misc.AutoStandFromFeign,${feignAutoStand}]}
	/varset followMaxResponseDist ${getBotIniOption[Misc.FollowMaxResponseDist,${followMaxResponseDist}]}

	/if (${meleeStickFlags.Equal[FALSE]}) /varset meleeStickFlags

	/RETURN
}


SUB movementMaintenance() {
	/if (${Me.Moving}==TRUE) /varset movingTimer 10
	/if (${Me.Ducking}==TRUE) /stand

	/if (${Me.Feared.ID}!=NULL && ${fearReturnToStart}==TRUE) {
		/if (${fearStartXYZ.Equal[-]}) /varset fearStartXYZ ${Me.X} ${Me.Y} ${Me.Z}
	} else {
		/if (${fearStartXYZ.NotEqual[-]} && ${MathDistanceXYZ[${fearStartXYZ.Replace[ ,,]}]}>20) {
			/nav locxyz ${fearStartXYZ}
			/delay 10
			/RETURN RESET
		} else {
			/varset fearStartXYZ -
		}
	}

	/if (${Me.Feigning}==TRUE) {
		/if (${feignAutoStand}==TRUE) {
			/delay 10
			/stand
		}
	}

	/if (${stickTargetID}==0) {
		/if (${Stick.Active}==TRUE) /stick off
		/RETURN
	}

	/if (${anchorXYZ.NotEqual[-]}) {
		/if (${MathDistanceXYZ[${anchorXYZ.Replace[ ,,]}]}>10) {
			/if (${Stick.Active}==TRUE) /stick off
			/if (${Nav.Active}==FALSE) /nav locxyz ${anchorXYZ}
		}
		/RETURN
	}

	/if (${stickStartZone} != 0 && ${Zone.ID}!=${stickStartZone}) {
		/call movementStop
		/return
	}

	/if (${Spawn[id ${stickTargetID}].ID}==NULL || ${Spawn[id ${stickTargetID}].Dead}==TRUE) {
		/if (${Nav.Active}) /nav stop
		/if (${Stick.Active}) /stick off
		/call movementStop
		/RETURN
	}

	/if (${stickLockoutTimer}>0) /RETURN
	/if (${stickRoamLockoutTimer}>0) /RETURN

	/if (${Spawn[id ${stickTargetID}].LineOfSight}==FALSE && ${followUseNavAssist}==TRUE) {
		/if (${Nav.PathExists[id ${stickTargetID}]}==TRUE) {
			/if (${Nav.Active}==FALSE) /nav id ${stickTargetID}
			/RETURN
		}
	}

	/if (${Stick.StickTarget}!=${stickTargetID} || ${Stick.Active}==FALSE || ${needRestick}==TRUE || ${Me.FeetWet}==TRUE && ${feetWetStickTimer}==0) {
		/if (${Nav.Active}==TRUE) /nav stop
		|/bc /stick id ${stickTargetID} ${activeStickDistance} ${activeStickFlags}
		/stick id ${stickTargetID} ${activeStickDistance} ${activeStickFlags}
		/if (${Me.Sitting}==TRUE) /stand
		/varset needRestick FALSE
		/if (${Me.FeetWet}==TRUE) /varset feetWetStickTimer 40
	}


	| BECAUSE STICK WILL FREAK OUT ALONG WALLS, RE-FACING THE MOB MAINTAINS PROPER MELEEING
	/if (${refaceTimer}==0) {
		/squelch /face fast id ${stickTargetID}
		/varset refaceTimer 5
	}

	/RETURN
}

SUB movementLockoutStick(string t) {
	/if (${Stick.Active}==TRUE) {
		/stick off
		/moveto stop
		/delay 12
	}
	
	/varset stickLockoutTimer ${t}
	/RETURN
}

SUB movementRoamMoveStart(string cmd, string opts) {
	/varset stickRoamLockoutTimer 30

	/RETURN
}

SUB movementAnchor(string cmd, string opts) {
	/varset anchorXYZ ${getStackCommandOpt[${opts},LOCXYZ]}
	/RETURN
}


SUB movementRaiseAnchor(string cmd, string opts) {
	/varset anchorXYZ -
	/RETURN
}

SUB movementFollowDistCheck(string cmd, string opts) {
	/declare tmpID int local ${getStackCommandOpt[${opts},SPAWNID]}

	/if (${Spawn[id ${tmpID}].Distance3D}>${followMaxResponseDist}) {
		/RETURN RESET
	}
	
	/RETURN
}

SUB movementFollow (string cmd, string opts) {

	/varset stickMode FOLLOW

	/varset stickTargetID ${getStackCommandOpt[${opts},SPAWNID]}
	/varset stickStartZone ${Zone.ID}

	/call setActiveStickParams ${stickMode}

	/RETURN
}

SUB movementStop(string cmd, string opts) {
	/varset stickTargetID 0
	/varset stickStartZone 0
	/moveto stop
	/stick off
	/if (${Nav.Active}==TRUE) /nav stop

	/RETURN
}

SUB movementKill(string cmd, string opts) {
	/varset stickMode MELEE

	/if (${useMeleeCombat}==TRUE) {
		/varset stickTargetID ${getStackCommandOpt[${opts},SPAWNID]}
		/call setActiveStickParams ${stickMode}
	} else {
		/varset stickTargetID 0
	}

	/RETURN
}

SUB setActiveStickParams(string mode) {
	/if (${mode.Equal[MELEE]}) {
		/varset activeStickFlags ${meleeStickFlags}
		/varset activeStickDistance ${meleeStickDistance}
		/if (${tankModeEnabled}==TRUE) /varset activeStickFlags ${activeStickFlags.Replace[BEHIND,]}
	} else /if (${mode.Equal[FOLLOW]}) {
		/varset activeStickFlags ${followStickFlags}
		/varset activeStickDistance ${followStickDistance}
	}
	/RETURN
}
SUB p3_retreat_init() {
	/call p3RegisterCommand RETREATON retreatOn 50
	/call p3RegisterCommand RETREATOFF retreatOff 50

	/declare meleeRetreat bool outer FALSE
	/declare meleeRetreatPercent int outer 40
	/declare meleeRetreatResumePercent int outer 75
	/declare meleeRetreatLoc string outer -
	/declare amMeleeRetreating bool outer FALSE

	/varset meleeRetreatPercent ${getBotIniOption[Assist.RetreatPercent,${meleeRetreatPercent}]}
	/varset meleeRetreatResumePercent ${getBotIniOption[Assist.RetreatResumePercent,${meleeRetreatResumePercent}]}

	/RETURN
}

SUB retreatMaintenance() {
	/if (${meleeRetreat}==TRUE) /call checkMeleeRetreat

	/RETURN	
}

SUB retreatOn(string cmd, string opts) {
	/varset meleeRetreat TRUE
	/varset meleeRetreatLoc ${getStackCommandOpt[${opts},LOCXYZ]}
	/bc Retreating at ${meleeRetreatLoc}.
	/RETURN
}

SUB retreatOff(string cmd, string opts) {
	/varset meleeRetreat FALSE
	/varset meleeRetreatLoc -
	/bc Retreat mode is now off.
	/RETURN
}


SUB checkMeleeRetreat() {
	/if (${Me.PctHPs} < ${meleeRetreatPercent} && ${amMeleeRetreating}==FALSE) {
		/varset amMeleeRetreating TRUE
		/invoke (${cq.Append[DROPANCHOR;LOCXYZ=${meleeRetreatLoc};]})
		/RETURN
	}

	/if (${Me.PctHPs} >= ${meleeRetreatResumePercent} && ${amMeleeRetreating}==TRUE) {
		/varset amMeleeRetreating FALSE
		/invoke (${cq.Append[RAISEANCHOR;]})
		/RETURN
	}

	/RETURN
}
SUB p3_roam_init() {
	/call p3RegisterCommand ROAMLOCK roamRoam 50
	/call p3RegisterCommand ROAMOFF roamRoamOff 50
	/call p3RegisterCommand CAMPON roamCampOn 60
	
	/declare roamTargetID int outer 0
	/declare roamMode bool outer FALSE
	/declare roamRefreshTimer timer outer 0
	/declare roamTargetZoneID int outer 0

	/declare roamFlyDown bool outer FALSE
	/varset roamFlyDown ${getBotIniOption[Misc.RoamFlyDown,${roamFlyDown}]}

	/RETURN
}


SUB roamMaintenance() {
	/if (${roamMode}==TRUE) /call checkRoam
	/RETURN
}

SUB roamRoamOff(string cmd, string opts) {
	/declare sourceName string local ${getStackCommandOpt[${opts},SOURCENAME]}
	/if (${Spawn[=${sourceName}].ID}==FALSE) /RETURN
	/if (${roamMode}==FALSE) /RETURN

	/call disableRoam

	/RETURN
}

SUB disableRoam() {
	/varset roamTargetZoneID 0
	/varset roamMode FALSE
	/bc Roam off.
	/RETURN
}

SUB roamCampOn(string cmd, string opts) {
	/if (${roamMode}==FALSE) /RETURN
	/call disableRoam
	/RETURN
}

SUB roamRoam(string cmd, string opts) {
	/declare targetID string local ${getStackCommandOpt[${opts},TARGETID]}

	/if (${targetID}==0) {
		/varset roamMode FALSE
		/bc Roam off.
	} else {
		/varset roamMode TRUE
		/varset roamTargetID ${targetID}
		/varset roamTargetZoneID ${Zone.ID}
		/bc Roaming with ${Spawn[id ${roamTargetID}].CleanName}
	}

	/RETURN
}

SUB checkRoam() {
	/if (${roamRefreshTimer}==0 && ${Spawn[id ${roamTargetID}].Distance3D}>40) {
		/invoke ${cq.Append[ROAMMOVESTART;]}

		/if (${assistSpawnID}!=0) {
			/call assistStop STOP STOP;ASSISTHOLDTIMER=20
		}
		
		/if (${Zone.ID}!=${roamTargetZoneID}) /RETURN

		/if (${navPlugin}==TRUE) {
			/if (${Navigation.PathExists[id ${roamTargetID}]}==FALSE) {
				/bc Can't find path to my roam target. Trying face/walk for 1s.
				/face fast id ${roamTargetID}
				/keypress FORWARD HOLD
				/delay 10
				/keypress FORWARD
				/return
			}

			/nav id ${roamTargetID}
			/if (${roamFlyDown}==TRUE) {
				/keypress CMD_MOVE_DOWN hold
				/timed 3 /keypress CMD_MOVE_DOWN
			}
		} else {
			/moveto loc ${Spawn[${roamTargetID}].Y} ${Spawn[${roamTargetID}].X} ${Spawn[${roamTargetID}].Z} 
		}
		/varset roamRefreshTimer 30
	}

	/RETURN
}

SUB p3_slay_init {
	/call p3RegisterCommand STOP slayStop 50
	/call p3RegisterCommand KILL slayKill 55

	/declare slayProxMobs list outer
	/declare slayTankStates[16] string outer -
	/declare slayCheckTimer timer outer 0
	/declare slaySearch string outer

	/declare slayEnabled bool outer 			FALSE

	/declare amSlayLeader bool outer			FALSE
	/declare slayMembers string outer			-
	/declare slayLevelRange string outer		1 80
	/declare slayRadius string outer			50
	/declare slayExtra string outer

	/varset amSlayLeader 			${getBotIniOption[Slay.Leader,${amSlayLeader}]}
	/varset slayMembers 			${getBotIniOption[Slay.Members,${slayMembers}]}
	/varset slayLevelRange 			${getBotIniOption[Slay.MobLevelRange,${slayLevelRange}]}
	/varset slayRadius 				${getBotIniOption[Slay.ScanRadius,${slayRadius}]}
	/varset slayExtra 				${getBotIniOption[Slay.ExtraParams,${slayExtra}]}

	/varset slaySearch npc los radius ${slayRadius} range ${slayLevelRange} ${slayExtra}

	/if (${amSlayLeader}==TRUE) {
		|/varset slayEnabled TRUE
		/call clearTankStates
	}

	/RETURN
}


SUB slayKill(string cmd, string opts) {
	/varset slayCheckTimer 2
	/RETURN
}


SUB slayStop(string cmd, string opts) {
	/call clearTankStates
	/varset slayCheckTimer 30
	/return
}

SUB slayMaintenance {
	/if (${Me.Invis}==TRUE) /return
	/if (${slayEnabled}==FALSE) /return
	/if (${amSlayLeader}==FALSE) /return
	/if (${slayCheckTimer}>0) /return
	/if ((${Stick.Active}==TRUE || ${Nav.Active}==TRUE) && ${assistSpawnID}==0) /RETURN

	/varset slayCheckTimer 5

	/call verifySlayTankStates
	/call scanMobs
	/call checkTankAssignments

	/RETURN
}


SUB scanMobs() {
	/declare mobCount int local
	/declare i int local
	/declare xSpawn spawn local

	/invoke ${slayProxMobs.Clear}

	/varset mobCount ${SpawnCount[${slaySearch} loc ${Me.X} ${Me.Y}]}

	/if (${mobCount}>0) {

		/for i 1 to ${mobCount}
			/vardata xSpawn NearestSpawn[${i},${slaySearch}]
			/if (${xSpawn.Aggressive}==FALSE) /continue
			/invoke ${slayProxMobs.Append[${xSpawn.ID}]}
		/next i
	}

	/varset mobCount ${SpawnCount[${slaySearch} loc ${Me.X} ${Me.Y} npcpet]}
	/if (${mobCount}>0) {
		/echo ${mobCount}
		/for i 1 to ${mobCount}
			/vardata xSpawn NearestSpawn[${i},${slaySearch} npcpet]
			/if (${xSapwn.Master.Type.Equal[PC]}) /continue
			/if (${xSpawn.Aggressive}==FALSE) /continue
			/invoke ${slayProxMobs.Append[${xSpawn.ID}]}
		/next i
	}

	/RETURN
}

SUB verifySlayTankStates() {
	/declare max int local ${Math.Calc[${slayMembers.Count[,]}+1]}
	/declare tankName string local
	/declare tankTargetID string local
	/declare i int local
	/declare e string local


	/for i 1 to ${max}
		/varset e ${slayTankStates[${i}]}
		/varset tankName ${e.Token[1,:]}
		/varset tankTargetID ${e.Token[2,:]}

		/if (${tankTargetID} != 0 && ${NetBots[${tankName}].TargetID} != ${tankTargetID}) {
			/varset slayTankStates[${i}] ${tankName}:0
		}

	/next i

	/RETURN
}


SUB clearTankStates() {
	/declare max int local ${Math.Calc[${slayMembers.Count[,]}+1]}
	/declare i int local

	/for i 1 to ${max}
		/varset slayTankStates[${i}] ${slayMembers.Token[${i},,]}:0
	/next i

	/RETURN
}

SUB checkTankAssignments() {
	/if (${slayProxMobs.Count}==0) /RETURN

	/declare i int local
	/declare mobID int local
	/declare freeTankIndex int local
	/declare freeTankName string local

	/for i 0 to ${Math.Calc[${slayProxMobs.Count}-1]}
		/varset freeTankIndex ${getFreeTankIndex[]}
		/varset freeTankName ${slayTankStates[${freeTankIndex}].Token[1,:]}
		/varset mobID ${slayProxMobs.Item[${i}]}]}

		/if (${freeTankIndex}==NULL) /RETURN

		/if (${arrayIndexOf[slayTankStates,:${slayProxMobs.Item[${i}]}]}==NULL) {
			/varset slayTankStates[${freeTankIndex}] ${freeTankName}:${mobID}
			/bct ${freeTankName} assist on ${mobID}
			/BC ${freeTankName} slay on ${mobID}
		}
	/next i

	/RETURN
}

SUB getFreeTankIndex() {
	/declare i int local
	/declare tankName string local

	/for i 0 to ${Math.Calc[${slayTankStates.Size}-1]}
		/varset tankName ${slayTankStates[${i}].Token[1,:]}
		/if (${Spawn[=${tankName}].ID}==NULL) /continue
		/if (${slayTankStates[${i}].Find[:0]}!=NULL) /return ${i}
	/next i

	/RETURN NULL
}

SUB arrayIndexOf(string arr, string search) {
	/declare i int local

	/for i 0 to ${Math.Calc[${${arr}.Size}-1]}
		/if (${${arr}[${i}].Find[${search}]}!=NULL) {
			/return ${i}
		}
	/next i

	/RETURN NULL
}

SUB slayBuildTeam() {
	/declare i int local
	/declare j int local 
	/declare c string local
	/declare botName string local
	/declare finalMembers string local

	/declare prefTankOrder list local
	/invoke ${prefTankOrder.Append[WAR,PAL,SHD,MNK,RNG,ROG,BST,BER]}

	/for i 1 to ${Math.Calc[${prefTankOrder.Count}-1]}
		/varset c ${prefTankOrder.Item[${i}]}

		/for j 1 to ${NetBots.Counts}
			/varset botName ${NetBots.Client[${j}]}

			/if (${NetBots[${botName}].Class.ShortName.Equal[${c}]}) {
				/varset finalMembers ${finalMembers},${botName}
			}
		/next j
	/next i

	/varset finalMembers ${finalMembers.Right[-1]}
	/varset slayMembers ${finalMembers}

	/call writeBotIniOption "Slay.Members" "${finalMembers}"

	/echo New Slay Team/Order:  ${finalMembers}

	/RETURN
}

SUB p3_spellcombat_init {
	/call p3RegisterCommand TAGSCHANGED spellcombatTagsChanged 10

	/call p3RegisterCommand KILL spellcombatKill 50
	/call p3RegisterCommand STOP spellcombatStop 50

	/declare combatSpellsCheckTimer timer outer 0
	/declare spellKillID int outer 0

	/call validateTagsFromArray iniCombatSpells

	/RETURN
}


SUB spellcombatTagsChanged() {
	/call validateTagsFromArray iniCombatSpells
	/RETURN
}

SUB spellcombatKill(string cmd, string opts) {
	/varset spellKillID ${getStackCommandOpt[${opts},SPAWNID]}

	/RETURN
}

SUB spellcombatStop(string cmd, string opts) {
	/varset spellKillID 0

	/RETURN
}

SUB spellcombatMaintenance() {
	/declare killSpawn spawn local

	/if (${spellKillID}==0) /RETURN

	/if (${Spawn[id ${spellKillID}].ID}==NULL || ${Spawn[id ${spellKillID}].Dead}==TRUE) {
		/call spellcombatStop
		/RETURN
	}

	/vardata killSpawn Spawn[id ${spellKillID}]

	/if (${killSpawn.ID}==NULL || ${killSpawn.Dead}==TRUE) {
		/call spellcombatStop
		/RETURN
	}

	/if (${assistMustHaveName.NotEqual[FALSE]}) {
		/if (${killSpawn.CleanName.Upper.Find[${assistMustHaveName.Upper}]}==NULL) {
			/call spellcombatStop
			/RETURN
		}
	}
	/if (${assistMustNotHaveName.NotEqual[FALSE]}) {
		/if (${killSpawn.CleanName.Upper.Find[${assistMustNotHaveName.Upper}]}!=NULL) {
			/call spellcombatStop
			/RETURN
		}
	}

	/if (${spellKillID}!=0) {
		/call checkCombatSpells
	}

	/RETURN
}

SUB checkCombatSpells {
	/if (${combatSpellsCheckTimer}>0) /return
	/if (${Me.Casting.ID}!=NULL) /return
	
	/varset combatSpellsCheckTimer 5

	/declare i int local
	/declare cSpell spell local
	/declare cSpellName string local
	/declare maxResists int local 5
	/declare currentResistCount int local 0
	/declare cancelConditions string local

	/declare lifeDeficit int local
	/declare lifeRatio int local

	/for i 1 to ${iniCombatSpells.Size}
		/varset cSpellName ${iniCombatSpells[${i},1]}
		/varset currentResistCount 0
		/varset maxResists 5
		/varset cancelConditions TARGETDEAD|

		/if (${cSpellName.Equal[-]}) /break

		/if (${iniCombatSpells[${i},${bEnabled}].Equal[NO]}) /continue
		/if (${iniCombatSpells[${i},${bTagsInvalidated}].Equal[YES]}) /continue

		/if (${iniCombatSpells[${i},${bNotIfMounted}].NotEqual[-]}) {
			/if (${Me.Mount.ID}!=NULL) /CONTINUE
		}
		
		/if (${iniCombatSpells[${i},${bAutoDebuffOnly}].NotEqual[-]}) {
			/continue
		}

		/if (${iniCombatSpells[${i},${bRequireCastIdle}].NotEqual[-]}) {
			/if (${idleCastingTimer}>0) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bGiftOfMana}].NotEqual[-]}) {
			/if (${Me.Song[Gift Of Mana].ID}==NULL) /continue
		}

		|/if (${iniCombatSpells[${i},${bNotIfAssistTag}].NotEqual[-]}) {
		|	/if (${assistTags.Count}>0 || ${assistTags.Count}>0) {
		|		/call validateAssistTags ${iniCombatSpells[${i},${bNotIfAssistTag}]} TRUE
		|		/if (${Macro.Return}==TRUE) /CONTINUE
		|	}
		|}

		|/if (${iniCombatSpells[${i},${bRequireAssistTag}].NotEqual[-]}) {
		|	/if (${assistTags.Count}==0 && ${assistTags.Count}==0) /CONTINUE
		|	/call validateAssistTags ${iniCombatSpells[${i},${bRequireAssistTag}]}
		|	/if (${Macro.Return}==FALSE) /CONTINUE
		|}

		/if (${iniCombatSpells[${i},${bMaxResists}].NotEqual[-]}) {
			/varset maxResists ${iniCombatSpells[${i},${bMaxResists}]}
		}

		/if (${iniCombatSpells[${i},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} <= ${iniCombatSpells[${i},${bSelfOverMana}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bSelfUnderHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} >= ${iniCombatSpells[${i},${bSelfUnderHP}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bSelfOverHP}].NotEqual[-]}) {
			/if (${Me.PctHPs} < ${iniCombatSpells[${i},${bSelfOverHP}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bSelfUnderMana}].NotEqual[-]}) {
			/if (${Me.PctMana} >= ${iniCombatSpells[${i},${bSelfUnderMana}]}) /CONTINUE
		}
		/if (${iniCombatSpells[${i},${bSelfOverMana}].NotEqual[-]}) {
			/if (${Me.PctMana} < ${iniCombatSpells[${i},${bSelfOverMana}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bSelfUnderEnd}].NotEqual[-]}) {
			/if (${Me.PctEndurance} >= ${iniCombatSpells[${i},${bSelfUnderEnd}]} ) /CONTINUE
		}
		/if (${iniCombatSpells[${i},${bSelfOverEnd}].NotEqual[-]}) {
			/if (${Me.PctEndurance} < ${iniCombatSpells[${i},${bSelfOverEnd}]} ) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bTargetOverLevel}].NotEqual[-]}) {
			/if (${Spawn[id ${spellKillID}].Level} < ${iniCombatSpells[${i},${bTargetOverLevel}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bTargetUnderLevel}].NotEqual[-]}) {
			/if (${Spawn[id ${spellKillID}].Level} >= ${iniCombatSpells[${i},${bTargetUnderLevel}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bRequireBodyType}].NotEqual[-]}) {
			/if (${Select[${Spawn[id ${spellKillID}].Body.Name},${iniCombatSpells[${i},${bRequireBodyType}]}]}==0) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bTargetRace}].NotEqual[-]}) {
			/if (${Select[${Spawn[id ${spellKillID}].Race},${iniCombatSpells[${i},${bTargetRace}]}]}==0) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bRequireMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 25]} < ${iniCombatSpells[${i},${bRequireMobsInProximity}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bRequireMaxMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 45]} > ${iniCombatSpells[${i},${bRequireMaxMobsInProximity}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bRequireTargetClass}].NotEqual[-]}) {
			/if (${Select[${Spawn[id ${spellKillID}].Class.ShortName},${iniCombatSpells[${i},${bRequireTargetClass}]}]}==0) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bTargetOverHP}].NotEqual[-]}) {
			/call fullTarget ${spellKillID}
			/if (${Macro.Return}==FALSE) /CONTINUE
			/if (${Target.PctHPs} < ${iniCombatSpells[${i},${bTargetOverHP}]}) /CONTINUE
			/varset cancelConditions ${cancelConditions}TARGETUNDERHP:${iniCombatSpells[${i},${bTargetOverHP}]}|
		}

		/if (${iniCombatSpells[${i},${bTargetUnderHP}].NotEqual[-]}) {
			/call fullTarget ${spellKillID}
			/if (${Macro.Return}==FALSE) /CONTINUE
			/if (${Target.PctHPs} >= ${iniCombatSpells[${i},${bTargetUnderHP}]}) /CONTINUE
		}

		/if (${iniCombatSpells[${i},${bTargetLifeManaRatio}].NotEqual[-]}) {
			/call fullTarget ${spellKillID}
			/if (${Macro.Return}==FALSE) /CONTINUE

			/varset lifeDeficit ${Math.Calc[100-${Target.PctHPs}]}
			/varset lifeRatio ${iniCombatSpells[${i},${bTargetLifeManaRatio}]}
			/if (${Me.PctMana} < ${Math.Calc[100-(${lifeDeficit}/${lifeRatio})]}) {
				/CONTINUE
			}
		}

		/if (${iniCombatSpells[${i},${bMemInGem}].NotEqual[-]} && ${Me.Gem[${cSpellName}]}==NULL) {
			/call memorizeSpellInGem "${cSpellName}" ${iniCombatSpells[${i},${bMemInGem}]}
		}

		/if (${isCastReady[${cSpellName}]}==FALSE) {
			/CONTINUE
		}

		/if (${iniCombatSpells[${i},${bNoCancelChecks}].NotEqual[-]}) {
			/varset cancelConditions TARGETDEAD|
		}

		/call getSpellFromCastRequest "${cSpellName}"
		/if (${Macro.Return.Equal[UNKNOWN]}) {
			/bc Warning: checkCombatSpells() getSpellFromCastRequest() returned UNKNOWN. Not sure what to do.
		} else {
			/vardata cSpell ${Macro.Return}
			/if (${isLockoutExpired[detriTimer_${cSpell.ID}]}==FALSE) /CONTINUE
			/if (${isLockoutExpired[detriTimer_${spellKillID}_${cSpell.ID}]}==FALSE) /CONTINUE
		
			/if (${cSpell.MyCastTime}>0 && ${movingTimer}>0) /CONTINUE
		}

		/invoke (${cq.Append[CAST;SPELL=${cSpellName};TARGETID=${spellKillID};CANCELCONDITIONS=${cancelConditions};SRC=combatSpells;SRCIDX=${i};ONRESULT=onCombatCastResult]})
		/BREAK

	/next i

	/RETURN
}

SUB onCombatCastResult(string result, string opts) {
	/RETURN
}


SUB p3_tank_init() {
	/call p3RegisterCommand TAGSCHANGED tankTagsChanged 50


	/declare tankModeEnabled bool outer FALSE
	/declare dontTakeAggroFrom string outer NONE
	/declare tauntSuccessList list outer
	/declare tankCheckTimer timer outer 0

	/varset tankModeEnabled ${getBotIniOption[Tank.Enabled,${tankModeEnabled}]}
	/varset dontTakeAggroFrom ${getBotIniOption[Tank.DontTakeAggroFromNames,${dontTakeAggroFrom}]}

	/RETURN
}


SUB tankMaintenance() {
	/if (${tankModeEnabled}==TRUE && ${tankCheckTimer}==0) {
		/call checkTauntSuccessList
		/call checkTankStatus
		/varset tankCheckTimer 5
	}

	/RETURN
}


SUB tankTagsChanged() {
	/call validateTagsFromArray iniTankActions
	/RETURN
}


SUB tankKill(string cmd, string opts) {
	/RETURN
}

SUB tankStop(string cmd, string opts) {
	/RETURN
}


SUB checkTankStatus() {
 /if (${assistSpawnID}==0) /return
 	/echo checking tank stuff

	/declare i int local

	/if (${dontTakeAggroFrom.NotEqual[NONE]} && ${Me.TargetOfTarget.ID}!=NULL) {
		/call characterPassesAllowKeySeries ${Me.TargetOfTarget.CleanName.Upper} "${dontTakeAggroFrom.Upper}"
		/if (${Macro.Return}==TRUE) /return
	}

	/for i 1 to ${iniTankActions.Size}

		/if (${iniTankActions[${i},${bTagsInvalidated}].Equal[YES]}) /continue
		/if (${iniTankActions[${i},${bEnabled}].Equal[NO]}) /continue
		/if (${iniTankActions[${i},1].Equal[-]}) /return

		/if (${iniTankActions[${i},${bNotToT}].NotEqual[-]}) {
			/if (${Me.TargetOfTarget.ID}==${Me.ID}) /continue
		}

		/if (${iniTankActions[${i},${bAmToT}].NotEqual[-]}) {
			/if (${Me.TargetOfTarget.ID}!=${Me.ID}) /continue
		}

		/if (${iniTankActions[${i},${bOnlyAfterTaunt}].NotEqual[-]}) {
			/if (${tauntSuccessListContains[${assistSpawnID}_]}==FALSE) {
				/continue
			}
		}

		|/if (${iniTankActions[${i},${bDoAbility}].NotEqual[-]}) {
		|	/if (${Me.AbilityReady[${iniTankActions[${i},1]}]} == FALSE) /continue 
		|}

		|/if (${iniTankActions[${i},${bSelfNotHighestAggro}].NotEqual[-]}) {
		|	/if (${Me.PctAggro}==100) /continue
		|}

		/if (${iniTankActions[${i},${bCombatTimeOver}].NotEqual[-]}) {
			/if (${Math.Calc[(12000-${assistTime})/10]} < ${iniTankActions[${i},${bCombatTimeOver}]}) /continue
		}

		/if (${iniTankActions[${i},${bSelfOverEnd}].NotEqual[-]}) {
			/if (${Me.PctEndurance} < ${iniTankActions[${i},${bSelfOverEnd}]} ) /continue
		}

		|/if (${iniTankActions[${i},${bNextHighestAggroOver}].NotEqual[-]}) {
		|	/if (${Me.PctAggro} != 100) /continue
		|	/if (${Me.SecondaryPctAggro} < ${iniTankActions[${i},${bNextHighestAggroOver}]}) /continue
		|}

		/if (${iniTankActions[${i},${bTargetUnderDistance}].NotEqual[-]}) {
			/if (${Target.Distance} > ${iniTankActions[${i},${bTargetUnderDistance}]}) /continue
		}

		/if (${iniTankActions[${i},${bRequireMobsInProximity}].NotEqual[-]}) {
			/if (${SpawnCount[npc loc ${Me.X} ${Me.Y} radius 30]} < ${iniTankActions[${i},${bRequireMobsInProximity}]}) /continue
		}

		/if (${iniTankActions[${i},${bDoCommand}].NotEqual[-]}) {
			/call p3command "${iniTankActions[${i},${bDoCommand}]}"
		}

		/echo SPELL=${iniTankActions[${i},1]}
		/invoke (${cq.Append[CAST;SPELL=${iniTankActions[${i},1]};TARGETID=${assistSpawnID};]})

	/next i

	/RETURN
}

SUB checkTauntSuccessList() {
	/if (${tauntSuccessList.Count}==0) /return

	/declare i int local 
	/declare t int local

	/for i ${Math.Calc[${tauntSuccessList.Count}-1]} downto 0
		/varset t ${tauntSuccessList.Item[${i}].Token[2,_]}

		/if (${Math.Calc[${MacroQuest.Running} - ${t} >5000]}) {
			/invoke ${tauntSuccessList.Erase[${i}]}
		}  

	/next i

	/RETURN
}



SUB tauntSuccessListContains(string s)
   /if (${tauntSuccessList.Count}==0) /return FALSE
   /declare i int local

   /for i 0 to ${Math.Calc[${tauntSuccessList.Count}-1]}
      /if (${tauntSuccessList.Item[${i}].Find[${s}]}!=NULL) /return TRUE
   /next i

   /return FALSE
/RETURN
SUB p3_targetting_init {
	/call p3RegisterCommand STOP targettingStop 51
	/call p3RegisterCommand KILL targettingKill 51
	/call p3RegisterCommand CAST targettingCast 10

	/declare lockTargetID int outer 0
	/declare castTargetID int outer 0

	/declare keepTargetClearWhileIdle bool outer FALSE

	/varset keepTargetClearWhileIdle ${getBotIniOption[Misc.KeepTargetClearWhileIdle,${keepTargetClearWhileIdle}]}

	/RETURN
}

SUB targettingMaintenance() {

	| MAINTAIN CAST TARGET LOCK UNTIL NO LONGER CASTING
	/if (${castTargetID}!=0) {
		/if (${Me.Casting.ID}==NULL) {
			/varset castTargetID 0
		} else {
			/if (${Target.ID}!=${castTargetID}) {
				/tar id ${castTargetID}
			}
		}
		/RETURN
	}

	| HANDLE REGULAR TARGET LOCK

	/if (${Spawn[id ${lockTargetID}].ID}==NULL || ${Spawn[id ${lockTargetID}].Dead}==TRUE) {
		/varset lockTargetID 0
	}

	|/if (${lockTargetID}==0 && ${Target.ID}!=NULL && ${keepTargetClearWhileIdle}==TRUE) /target clear

	/if (${lockTargetID}==0) /RETURN
	
	/if (${Target.ID}!=${lockTargetID}) {
		/tar id ${lockTargetID}
	}

	/RETURN
}

SUB targettingCast(string cmd, string opts) {
	/varset castTargetID ${getStackCommandOpt[${opts},TARGETID]}

	/if (${Target.ID}!=${castTargetID}) {
		/tar id ${castTargetID}
		/delay 10
	}

	/RETURN
}

SUB targettingStop(string cmd, string opts) {
	/if (${useMeleeCombat}==TRUE) {
		/varset lockTargetID 0
	}

	/RETURN
}

SUB targettingKill(string cmd, string opts) {
	/if (${useMeleeCombat}==TRUE) {
		/varset lockTargetID ${getStackCommandOpt[${opts},SPAWNID]}
	}

	/RETURN
}
SUB p3_template_init() {
	
	/RETURN
}


SUB templateMaintenance() {
	
}

| todo:
| add hott type for heals




#turbo 120

SUB MAIN {
	|/wire drawchaton
	|/wire BGRenderRate 100

	/echo p3 alpha [0.10k]: Starting...

	/declare cq list outer
	/declare cqHead string outer
	/declare commands list outer
	/declare modules list outer
	/declare navPlugin bool outer FALSE
	/declare perfLog list outer
	/declare perfStart int outer
	/declare perfIdle int outer
	/declare st int local
	/declare et int local
	/declare hardLoopReset bool outer FALSE
	/declare lastZonedMark int outer 0
	/declare recentlyZoned bool outer FALSE

	/invoke ${cq.Delimiter[^]}
	/invoke ${modules.Append[global,eqemu,assist_tags,targetting,casting,castorders,charm,movement,automez,autodebuff,assist,tank,exptrack,automed,heals,meleecombat,spellcombat,autoabilities,buffs,buffrequests,bardtwist,slay,camp,retreat,roam,autotrapdisarm,autodispell,mine]}

	/call importCommandLine "${Param0}" "${Param1}" "${Param2}" "${Param3}" "${Param4}"
	/call p3Setup
	/call checkPlugins
	/call initializeModules

	/echo p3 alpha:Startup complete.
	/setwintitle ${Me.CleanName}

	/varset perfStart ${MacroQuest.Running}

	/while (1) {
		/if (!${MacroQuest.GameState.Equal[INGAME]}) /end
		/if (!${Bool[${Me.Class}]}) /endmacro


		/call checkZoning
		/call checkCommandQueue
		/if (${cq.Count}>0) /continue

		/call checkMaintenance

		/varset st ${MacroQuest.Running}
		/delay 1
		/varset et ${MacroQuest.Running}
		/varset perfIdle ${Math.Calc[${perfIdle}+ (${et}-${st})]}
	}

	/END
}

SUB checkZoning {
	/if (${Me.LastZoned}!=${lastZonedMark}) {
		/varset lastZonedMark ${Me.LastZoned}
		/varset recentlyZoned TRUE
		/timed 80 /varset recentlyZoned FALSE
	}

	/RETURN
}

SUB checkMaintenance {
	/declare i int local
	/declare st int local
	/declare et int local

	/for i 0 to ${Math.Calc[ ${modules.Count}-1 ]}
		/doevents
		/if (${hardLoopReset}==TRUE) {
			/varset hardLoopReset FALSE
			/break
		}

		/varset st ${MacroQuest.Running}
		|/echo ${modules.Item[${i}]}Maintenance
		/call ${modules.Item[${i}]}Maintenance

		/varset et ${MacroQuest.Running}
		/varset p3_${modules.Item[${i}]}_perftime ${Math.Calc[${p3_${modules.Item[${i}]}_perftime} + (${et}-${st})]}

		/if (${Macro.Return.Equal[RESET]}) /break
		
	/next i

	/RETURN
}

SUB checkCommandQueue {
	/declare root string local
	/declare opts string local
	/declare i int local

	/if (${cq.Count}==0) /return FALSE

	/varset cqHead ${cq.Head}

	/varset root ${cqHead.Token[1,;]}

	/if (${Defined[commandStack${root}]}==FALSE) {
		/echo Unknown root command: ${root}
		/return
	} else {
		/for i 0 to ${Math.Calc[ ${commandStack${root}.Count}-1 ]}
			|/echo /call ${commandStack${root}.Item[${i}].Token[2,:]} "${root}" "${cqHead}"
			/call ${commandStack${root}.Item[${i}].Token[2,:]} "${root}" "${cqHead}"
			/if (${Macro.Return.Equal[RESET]}) {
				/echo FALSE caught. Abanoning chain: ${commandStack${root}.Item[${i}].Token[2,:]}
				/break
			}
		/next i
	}

	/RETURN
}

SUB importCommandLine(string Param0, string Param1, string Param2, string Param3, string Param4, string Param5) {
	/declare commandLine[8] string outer
	/declare cmdINI string outer 1
	/declare cmdTAGS string outer 2
	/declare cmdDEBUG string outer 3
	/declare cmdDIRECTINI string outer 4
	/declare cmdPAST string outer 5

	/declare opts list local
	/invoke ${opts.Delimiter[|]}
	/declare i int local

	/declare k string local
	/declare v string local

	/if (${Bool[${Param0}]}==TRUE) {
		/invoke ${opts.Append[${Param0}]}
	}
	/if (${Bool[${Param1}]}==TRUE) {
		/invoke ${opts.Append[${Param1}]}
	}
	/if (${Bool[${Param2}]}==TRUE) {
		/invoke ${opts.Append[${Param2}]}
	}
	/if (${Bool[${Param3}]}==TRUE) {
		/invoke ${opts.Append[${Param3}]}
	}
	/if (${Bool[${Param4}]}==TRUE) {
		/invoke ${opts.Append[${Param4}]}
	}
	/if (${Bool[${Param5}]}==TRUE) {
		/invoke ${opts.Append[${Param5}]}
	}

	/if (${opts.Count}==0) /RETURN

	/for i 0 to ${Math.Calc[ ${opts.Count}-1 ]}
		/varset k ${opts.Item[${i}].Token[1,=].Upper}
		/varset v ${opts.Item[${i}].Token[2,=]}

		/if (${Defined[cmd${k}]}==TRUE) {
			/varset commandLine[${cmd${k}}] ${v}
		}
	/next i

	/RETURN
}

SUB p3Setup {
	/declare generalIniFile string outer p3_bots\general.ini

	/declare defaultMeleeCombatClasses string outer BRD,BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
	/declare defaultSpellCombatClasses string outer CLR,DRU,NEC,WIZ,MAG,ENC,SHM
	/declare manaClasses string outer CLR,DRU,ENC,PAL,BRD,WIZ,MAG,SHM,NEC,BST,SHD
	/declare manaRegenClasses string outer CLR,DRU,ENC,PAL,WIZ,MAG,SHM,BST,SHD
	/declare hasteClasses string outer MNK,ROG,WAR,RNG,BST,SHD,BER
	/declare meleeClasses string outer BRD,BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
	/declare priestClasses string outer CLR,DRU,SHM
	/declare hybridClasses string outer PAL,BST,BRD,RNG
	/declare pureCasterClasses string outer ENC,MAG,NEC,WIZ
	/declare rangedClasses string outer CLR,DRU,SHM,ENC,MAG,NEC,WIZ
	/declare castWhileMovingClasses string outer ROG,MNK,BRD
	/declare tankClasses string outer WAR,PAL,SHD
	/declare knightClasses string outer PAL,SHD
	/declare canCastWhileMoving bool outer ${Me.Class.ShortName.Equal[BRD]}
	/declare amBard bool outer ${Me.Class.ShortName.Equal[BRD]}

	/declare cfNone int outer 0
	/declare cfMoving int outer 1
	/declare cfNaving int outer 2
	/declare cfSticking int outer 4
	/declare cfCasting int outer 8
	/declare cfInvis int outer 16

	/squelch /moveto set dist 10

	/RETURN
}

SUB initializeModules {
	/declare i int local

	/for i 0 to ${Math.Calc[ ${modules.Count}-1 ]}
		/declare p3_${modules.Item[${i}]}_perftime int outer
		/call p3_${modules.Item[${i}]}_init
	/next i

	/for i 0 to ${Math.Calc[ ${commands.Count}-1 ]}
		/invoke ${commandStack${commands.Item[${i}]}.Sort}
	/next i

	/RETURN
}

SUB checkPlugins () {
	/if (${Plugin[MQ2EQBC].Name.Length}==NULL) {
		/echo >>> MQ2EQBC not loaded. Cannot continue. Ending.
		/end
	}

	/if (${Plugin[MQ2Dannet].Name.Length}==NULL) {
		/echo >>> MQ2Dannet not loaded.  ExtendedStackCheck flag will not function.
	}

	/if (${Plugin[MQ2Collections].Name.Length}==NULL) {
		/echo >>> MQ2Collections not loaded. Cannot continue. Ending.
		/end
	}

	/if (${Bool[${EQBC}]}) {
		/if (!${EQBC.Connected}) {
			/bccmd connect
			/delay 100 ${EQBC.Connected}
			/delay 5
			/if (!${EQBC.Connected}) /echo >>> Could not connect to EQBCS.  Macro functionality will be very limited.
		}
	}
	
	/if (${Plugin[MQ2NetBots].Name.Length}==NULL) {
		/echo MQ2NetBots not loaded. Cannot continue. Ending.
		/end
	} else {
		/if (${NetBots}) {
			/squelch /netbots on grab=on send=on
		}	
	}

	/if (${Plugin[MQ2Nav].Name.Length}==NULL) {
		/echo MQ2Nav Plugin not loaded. Some movements mechanics will be limited.
	} else {
		/varset navPlugin TRUE
	}

	/if (${Plugin[MQ2MoveUtils].Name.Length}==NULL) {
		/echo MQ2MoveUtils not loaded. Cannot continue. Ending.
		/end
	}

	/RETURN
}

SUB p3RegisterCommand(string cmd, string funcName, string order) {
	/varset order ${strPad[${order}]}
	/varset cmd ${cmd.Upper}
	/declare stackName string local commandStack${cmd}

	/if (${commands.Contains[${cmd}]}==FALSE) {
		/invoke ${commands.Append[${cmd}]}
	}

	/if (${Defined[${stackName}]}==FALSE) {
		/declare ${stackName} list outer
	}

	/invoke ${${stackName}.Append[${order}:${funcName}]}

	/RETURN
}

SUB getStackCommandOpt (string opts, string k) {
	/declare sp int local ${opts.Find[;${k}=]}
	/declare ret string local -

	/if (${sp}!=NULL) {
		/varset ret ${opts.Right[-${sp}].Token[1,;].Token[2,=]}
	}

	/RETURN ${ret}
}

SUB getBotIniOption(string opt, string defaultResponse, string iniSource) {
	/if (${iniSource.Length}==0) /varset iniSource bot

	/declare iniKey string local 
	/declare iniValue string local
	/declare useSource string local
	/if (${iniSource.Equal[general]}) /varset useSource ${generalIniFile}
	/if (${iniSource.Equal[bot]}) /varset useSource ${botIniFile}


	/varset iniKey ${useSource},${opt.Token[1,.]},${opt.Token[2,.]}
	/varset iniValue ${Ini[${iniKey}]}

	/if (${iniValue.Equal[NULL]}) {
		/if (${defaultResponse.Equal[FALSE]}) /varset defaultResponse NO
		/if (${defaultResponse.Equal[TRUE]}) /varset defaultResponse YES
		/call writeBotIniOption "${opt}" "${defaultResponse}" ${iniSource}
		/RETURN ${defaultResponse}
	} else {
		/if (${iniValue.Upper.Equal[ON]} || ${iniValue.Upper.Equal[YES]} || ${iniValue.Upper.Equal[TRUE]}) {
			/RETURN TRUE
		} else /if (${iniValue.Upper.Equal[OFF]} || ${iniValue.Upper.Equal[FALSE]} || ${iniValue.Upper.Equal[NO]} || ${iniValue.Upper.Equal[NONE]} || ${iniValue.Upper.Equal[-]}) {
			/RETURN FALSE
		} else {
			/RETURN ${iniValue}
		}
	}

	/RETURN
}

SUB writeBotIniOption(string opt, string value, string iniSource) {
	/if (${iniSource.Length}==0) /varset iniSource bot

	/if (${iniSource.Equal[BOT]}) {
		/ini "${botIniFile}" "${opt.Arg[1,.]}" "${opt.Arg[2,.]}" "${value}"
	} else {
		/ini "${generalIniFile}" "${opt.Arg[1,.]}" "${opt.Arg[2,.]}" "${value}"
	}

	/RETURN
}

SUB getSpellFromCastRequest(string castRequest) {
	/if (${FindItemCount[=${castRequest}]}>0) /return FindItem[=${castRequest}].Spell
	/if (${Spell[${castRequest}].ID}) /return Spell[${castRequest}]
	/if (${Me.AltAbility[${castRequest}].ID}) /return Me.AltAbility[${castRequest}].Spell
	/echo check: ${castRequest}
	/if (${Me.CombatAbility[${castRequest}].ID}) {
		/return Spell[${castRequest}]
		|/varset combatAbilityIndex ${Me.CombatAbility[${castRequest}]}
		|/return CombatAbility[${combatAbilityIndex}]
	}
	/if (${Me.Ability[${castRequest}]}!=NULL) /return ABILITY

	/RETURN UNKNOWN
}

SUB isLockoutExpired(string timerName) {
	/if (${Defined[${timerName}]}==TRUE) {
		|/echo ${timerName} was defined. val:  ${${timerName}}
		/if (${${timerName}}==0) {
			/deletevar ${timerName}
			/return TRUE
		} else {
			/return FALSE
		}
	}
	/return TRUE
}

SUB lockout(string timerName, string dur) {
	/if (${dur.Right[1].Equal[s]}) {
		/varset dur ${Math.Calc[${dur.Left[-1]}*10]}
	}

	/if (${Defined[${timerName}]}==TRUE) {
		/if (${${timerName}}<${dur}) {
			/varset ${timerName} ${dur}
		}
	} else {
		/declare ${timerName} timer outer ${dur}
	}

	/RETURN
}

SUB wipeLockout(string timerName) {
	/if (${Defined[${timerName}]}==TRUE) {
		/deletevar ${timerName}
	}
	/RETURN
}

SUB isCastReady(string request) {
	/declare castType string local

	/call getCastTypeByCastRequest "${request}"
	/varset castType ${Macro.Return}

	/if (${castType.Equal[UNKNOWN]}) /return FALSE

	/if (${Me.Silenced.ID}!=NULL) /return FALSE

	/if (${castType.Equal[SPELL]}) {
		/if (${Me.Class.ShortName.Equal[BRD]} && ${Me.SpellInCooldown}==TRUE) /RETURN TRUE
		/if (${Me.SpellReady[${request}]}==FALSE) /RETURN FALSE
		/if (${Me.CurrentMana}<${Spell[${request}].Mana}) /RETURN FALSE
	}

	/if (${castType.Equal[ALTABILITY]} && ${Me.AltAbilityReady[${request}]}==FALSE) /return FALSE
	/if (${castType.Equal[ITEM]} && ${Me.ItemReady[${request}]}==FALSE) /return FALSE
	/if (${castType.Equal[SPELL]} && ${Me.SpellInCooldown}==TRUE && ${Me.Class.ShortName.NotEqual[BRD]}) /return FALSE
	/if (${castType.Equal[DISCIPLINE]} && ${Me.ActiveDisc.ID}!=NULL) /return FALSE
	/if (${castType.Equal[DISCIPLINE]} && ${Me.CombatAbilityReady[${request}]}==FALSE) /return FALSE
	/if (${castType.Equal[ABILITY]} && ${Me.AbilityReady[${Me.Ability[${request}]}]}==FALSE) /return FALSE
	
	/return TRUE
}

SUB getCastTypeByCastRequest(string castRequest) {
	/if (${Me.AltAbility[${castRequest}].ID}) /return ALTABILITY
	/if (${Me.CombatAbility[${castRequest}]}) /return DISCIPLINE
	
	| changed to me.spell because bash was showing up with just "spell"
	/if (${Me.Spell[${castRequest}].ID}) /return SPELL
	
	/if (${FindItemCount[${castRequest}]}) /return ITEM
	/if (${Me.Ability[${castRequest}]}!=NULL) /return ABILITY
	/RETURN UNKNOWN
}

SUB p3command(string cmd) {
	/varset cmd ${cmd.Replace[`,\\"].Replace[\,]}

	/if (${cmd.Find[!!]}!=NULL) {
		/docommand ${cmd.Replace[!!,$]}
	} else {
		/docommand ${cmd}
	}
	/RETURN
}

SUB iniSectionExists(string sectionName) {
	/declare i int local
	/varset i ${Select[${sectionName},${Ini[${botIniFile}].Replace[|,,]}]}

	/if (${i}==0) /RETURN FALSE

	/RETURN TRUE
}

SUB getSpellDurationByRequestName(string castRequest) {
	/declare s spell local
	/call getSpellFromCastRequest "${castRequest}"
	/if (${Macro.Return.Equal[UNKNOWN]}) /RETURN 0
	/if (${Macro.Return.Equal[ABILITY]}) {
		/bc Warning: getSpellDurationByRequestName() performed against an ABILITY. Defaulting to 3 seconds.
		/RETURN 3
	}

	/vardata s ${Macro.Return}

	/RETURN ${s.MyDuration.TotalSeconds}
}

SUB MathDistanceXYZ(string x, string y, string z) {
	/RETURN ${Math.Distance[${y} ${x} ${z}]}
}

SUB checkOpenWindows() {
	/if (${Window[BigBankWnd].Open})    /return TRUE
	/if (${Window[TradeWnd].Open})      /return TRUE
	/if (${Window[GuildBankWnd].Open})  /return TRUE
	/if (${Window[MerchantWnd].Open})   /return TRUE
	/if (${Window[SpellBookWnd].Open})  /return TRUE
	/return FALSE
}

SUB clearStackActions(string action) {
	
	/declare i int local

	/if (${cq.Count}==0) /return

	/for i ${Math.Calc[${cq.Count}-1]} downto 0
		/if (${cq.Item[${i}].Token[1,;].Equal[${action}]}) {
			/invoke ${cq.Erase[${i}]}
		}
	/next i

	/RETURN
}
